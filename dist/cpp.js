var _=t=>{t.languages.register({id:"cpp"}),t.languages.setMonarchTokensProvider("cpp",{defaultToken:"",tokenPostfix:".cpp",keywords:["alignas","alignof","and","and_eq","asm","auto","bitand","bitor","break","case","catch","class","compl","concept","const","consteval","constexpr","constinit","const_cast","continue","co_await","co_return","co_yield","decltype","default","delete","do","dynamic_cast","else","enum","explicit","export","extern","final","for","friend","goto","if","import","inline","module","mutable","namespace","new","noexcept","not","not_eq","operator","or","or_eq","override","private","protected","public","register","reinterpret_cast","requires","return","sizeof","static","static_assert","static_cast","struct","switch","template","this","thread_local","throw","try","typedef","typeid","typename","union","using","virtual","volatile","while","xor","xor_eq"],typeKeywords:["bool","char","char8_t","char16_t","char32_t","double","float","int","long","short","signed","unsigned","void","wchar_t","int8_t","int16_t","int32_t","int64_t","uint8_t","uint16_t","uint32_t","uint64_t","size_t","ptrdiff_t","nullptr_t","string","wstring","string_view","vector","map","unordered_map","set","unordered_set","list","deque","array","queue","stack","priority_queue","pair","tuple","optional","variant","any","shared_ptr","unique_ptr","weak_ptr","atomic","mutex","thread","future","promise"],constants:["true","false","nullptr","NULL","EOF","INFINITY","NAN","INT_MAX","INT_MIN","UINT_MAX","LONG_MAX","LONG_MIN","SIZE_MAX","__cplusplus","__LINE__","__FILE__","__func__"],operators:["=",">","<","!","~","?",":","==","<=",">=","!=","&&","||","++","--","+","-","*","/","&","|","^","%","<<",">>","+=","-=","*=","/=","&=","|=","^=","%=","<<=",">>=","->","->*","::",".*","..."],symbols:/[=><!~?:&|+\-*\/\^%]+/,escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8}|[0-7]{1,3})/,integersuffix:/(ll|LL|u|U|l|L)?(ll|LL|u|U|l|L)?/,floatsuffix:/[fFlL]?/,tokenizer:{root:[[/^\s*#\s*\w+/,"keyword.directive"],[/[a-zA-Z_]\w*/,{cases:{"@keywords":"keyword","@typeKeywords":"type","@constants":"constant","@default":"identifier"}}],{include:"@whitespace"},[/[{}()\[\]]/,"@brackets"],[/[<>](?!@symbols)/,"@brackets"],[/@symbols/,{cases:{"@operators":"operator","@default":""}}],[/\d*\.\d+([eE][\-+]?\d+)?@floatsuffix/,"number.float"],[/0[xX][0-9a-fA-F]+@integersuffix/,"number.hex"],[/0[bB][01]+@integersuffix/,"number.binary"],[/0[0-7]+@integersuffix/,"number.octal"],[/\d+@integersuffix/,"number"],[/"([^"\\]|\\.)*$/,"string.invalid"],[/"/,"string","@string_double"],[/'[^\\']'/,"string"],[/(')(@escapes)(')/,["string","string.escape","string"]],[/'/,"string.invalid"]],whitespace:[[/[ \t\r\n]+/,"white"],[/\/\*/,"comment","@comment"],[/\/\/.*$/,"comment"]],comment:[[/[^\/*]+/,"comment"],[/\*\//,"comment","@pop"],[/[\/*]/,"comment"]],string_double:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,"string","@pop"]]}}),t.languages.setLanguageConfiguration("cpp",{comments:{lineComment:"//",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"],["<",">"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:"<",close:">",notIn:["string"]},{open:'"',close:'"',notIn:["string"]},{open:"'",close:"'",notIn:["string","comment"]}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:"<",close:">"},{open:'"',close:'"'},{open:"'",close:"'"}],folding:{markers:{start:/^\s*#pragma\s+region\b/,end:/^\s*#pragma\s+endregion\b/}},indentationRules:{increaseIndentPattern:/^.*\{[^}"']*$|^.*\([^)"']*$/,decreaseIndentPattern:/^\s*[}\)]/},onEnterRules:[{beforeText:/^\s*\/\*\*(?!\/)([^\*]|\*(?!\/))*$/,afterText:/^\s*\*\/$/,action:{indentAction:t.languages.IndentAction.IndentOutdent,appendText:" * "}},{beforeText:/^\s*\/\*\*(?!\/)([^\*]|\*(?!\/))*$/,action:{indentAction:t.languages.IndentAction.None,appendText:" * "}},{beforeText:/^(\t|[ ])*[ ]\*([ ]([^\*]|\*(?!\/))*)?$/,action:{indentAction:t.languages.IndentAction.None,appendText:"* "}}]});let f={auto:{detail:"Keyword",doc:'Automatically deduces the type of a variable from its initializer.\n\n```cpp\nauto x = 42;       // int\nauto s = "hello"s; // std::string\n```'},class:{detail:"Keyword",doc:`Declares a class type. Members are private by default.

\`\`\`cpp
class MyClass {
public:
    int value;
    void doSomething();
};
\`\`\``},struct:{detail:"Keyword",doc:"Declares a struct type. Members are public by default.\n\n```cpp\nstruct Point {\n    double x, y;\n};\n```"},template:{detail:"Keyword",doc:"Declares a template for generic programming.\n\n```cpp\ntemplate<typename T>\nT max(T a, T b) { return a > b ? a : b; }\n```"},namespace:{detail:"Keyword",doc:"Declares a namespace to organize code and prevent name collisions.\n\n```cpp\nnamespace MyLib {\n    void func();\n}\n```"},typename:{detail:"Keyword",doc:"Used in template declarations to specify a type parameter, or to disambiguate dependent types.\n\n```cpp\ntemplate<typename T>\nvoid foo(typename T::value_type val);\n```"},const:{detail:"Keyword",doc:"Specifies that an object or variable is not modifiable.\n\n```cpp\nconst int MAX = 100;\nvoid func(const std::string& s);\n```"},constexpr:{detail:"Keyword (C++11)",doc:"Specifies that a value or function can be evaluated at compile time.\n\n```cpp\nconstexpr int square(int n) { return n * n; }\nconstexpr int val = square(5); // 25 at compile time\n```"},virtual:{detail:"Keyword",doc:`Declares a virtual function for runtime polymorphism.

\`\`\`cpp
class Base {
public:
    virtual void speak() { std::cout << "Base"; }
};
\`\`\``},override:{detail:"Keyword (C++11)",doc:'Indicates that a member function overrides a virtual function from a base class.\n\n```cpp\nvoid speak() override { std::cout << "Derived"; }\n```'},final:{detail:"Keyword (C++11)",doc:"Prevents a class from being inherited or a virtual function from being overridden."},static:{detail:"Keyword",doc:"Declares a variable or function with static storage duration, or a class member shared across all instances."},inline:{detail:"Keyword",doc:"Suggests the compiler to inline-expand a function. In C++17, also used for inline variables."},extern:{detail:"Keyword",doc:"Declares a variable or function that is defined in another translation unit."},mutable:{detail:"Keyword",doc:"Allows a member of a const object to be modified."},volatile:{detail:"Keyword",doc:"Indicates that an object may be changed by something external to the program."},explicit:{detail:"Keyword",doc:"Prevents implicit conversions or copy-initialization for constructors and conversion operators."},noexcept:{detail:"Keyword (C++11)",doc:"Specifies that a function does not throw exceptions.\n\n```cpp\nvoid func() noexcept;\n```"},decltype:{detail:"Keyword (C++11)",doc:"Inspects the declared type of an expression.\n\n```cpp\nint x = 5;\ndecltype(x) y = 10; // y is int\n```"},nullptr:{detail:"Literal (C++11)",doc:"A null pointer literal of type std::nullptr_t. Preferred over NULL or 0."},static_assert:{detail:"Keyword (C++11)",doc:'Performs a compile-time assertion.\n\n```cpp\nstatic_assert(sizeof(int) == 4, "int must be 4 bytes");\n```'},static_cast:{detail:"Keyword",doc:"Performs a safe, compile-time checked cast.\n\n```cpp\ndouble d = 3.14;\nint i = static_cast<int>(d);\n```"},dynamic_cast:{detail:"Keyword",doc:"Performs a runtime checked downcast for polymorphic types."},reinterpret_cast:{detail:"Keyword",doc:"Converts between unrelated pointer types. Use with caution."},const_cast:{detail:"Keyword",doc:"Adds or removes const/volatile qualification."},sizeof:{detail:"Keyword",doc:"Returns the size in bytes of a type or expression.\n\n```cpp\nsize_t s = sizeof(int); // typically 4\n```"},typeid:{detail:"Keyword",doc:"Returns type information about an expression or type (requires <typeinfo>)."},throw:{detail:"Keyword",doc:'Throws an exception.\n\n```cpp\nthrow std::runtime_error("error");\n```'},try:{detail:"Keyword",doc:"Begins a try block for exception handling."},catch:{detail:"Keyword",doc:"Handles an exception thrown by a try block.\n\n```cpp\ntry { ... }\ncatch (const std::exception& e) { ... }\n```"},if:{detail:"Keyword",doc:"Conditional statement.\n\n```cpp\nif (condition) { ... }\nelse if (other) { ... }\nelse { ... }\n```"},else:{detail:"Keyword",doc:"Alternative branch of an if statement."},for:{detail:"Keyword",doc:"Loop statement.\n\n```cpp\nfor (int i = 0; i < n; ++i) { ... }\nfor (auto& elem : container) { ... } // range-based\n```"},while:{detail:"Keyword",doc:"Loop that executes while a condition is true.\n\n```cpp\nwhile (condition) { ... }\n```"},do:{detail:"Keyword",doc:"Loop that executes at least once.\n\n```cpp\ndo { ... } while (condition);\n```"},switch:{detail:"Keyword",doc:`Multi-way branch statement.

\`\`\`cpp
switch (value) {
    case 1: ... break;
    default: ... break;
}
\`\`\``},case:{detail:"Keyword",doc:"A label in a switch statement."},default:{detail:"Keyword",doc:"Default label in switch, or default special member function (C++11)."},break:{detail:"Keyword",doc:"Exits the nearest enclosing loop or switch statement."},continue:{detail:"Keyword",doc:"Skips to the next iteration of the nearest enclosing loop."},return:{detail:"Keyword",doc:"Returns from a function, optionally with a value."},goto:{detail:"Keyword",doc:"Transfers control to a labeled statement. Generally discouraged."},enum:{detail:"Keyword",doc:"Declares an enumeration type.\n\n```cpp\nenum Color { Red, Green, Blue };\nenum class Fruit { Apple, Banana }; // scoped enum (C++11)\n```"},union:{detail:"Keyword",doc:"Declares a union type where all members share the same memory."},typedef:{detail:"Keyword",doc:"Creates an alias for a type.\n\n```cpp\ntypedef unsigned long ulong;\n```\nPrefer `using` in modern C++."},using:{detail:"Keyword",doc:"Introduces a name from a namespace, or creates a type alias (C++11).\n\n```cpp\nusing Vec = std::vector<int>;\nusing namespace std;\n```"},friend:{detail:"Keyword",doc:"Grants a function or class access to private/protected members."},delete:{detail:"Keyword",doc:"Deallocates memory (delete expression), or explicitly deletes a function (C++11).\n\n```cpp\ndelete ptr;\nMyClass(const MyClass&) = delete;\n```"},new:{detail:"Keyword",doc:"Allocates memory dynamically.\n\n```cpp\nint* p = new int(42);\nint* arr = new int[10];\n```"},this:{detail:"Keyword",doc:"Pointer to the current object within a member function."},concept:{detail:"Keyword (C++20)",doc:"Defines a named set of constraints for template arguments.\n\n```cpp\ntemplate<typename T>\nconcept Addable = requires(T a, T b) { a + b; };\n```"},requires:{detail:"Keyword (C++20)",doc:"Specifies constraints on template arguments or defines a requires expression."},co_await:{detail:"Keyword (C++20)",doc:"Suspends a coroutine and waits for a result."},co_return:{detail:"Keyword (C++20)",doc:"Returns a value from a coroutine."},co_yield:{detail:"Keyword (C++20)",doc:"Yields a value from a coroutine."},import:{detail:"Keyword (C++20)",doc:"Imports a module."},module:{detail:"Keyword (C++20)",doc:"Declares a module."},int:{detail:"Fundamental type",doc:"Signed integer type, typically 32 bits."},long:{detail:"Fundamental type",doc:"Signed integer type, at least 32 bits. `long long` is at least 64 bits."},short:{detail:"Fundamental type",doc:"Signed integer type, at least 16 bits."},char:{detail:"Fundamental type",doc:"Character type, exactly 1 byte."},bool:{detail:"Fundamental type",doc:"Boolean type. Values: `true` or `false`."},float:{detail:"Fundamental type",doc:"Single-precision floating point (typically 32-bit IEEE 754)."},double:{detail:"Fundamental type",doc:"Double-precision floating point (typically 64-bit IEEE 754)."},void:{detail:"Fundamental type",doc:"Incomplete type indicating no value. Used for functions returning nothing."},wchar_t:{detail:"Fundamental type",doc:"Wide character type."},size_t:{detail:"Type alias (<cstddef>)",doc:"Unsigned integer type for sizes and counts. Result of `sizeof`."},vector:{detail:"std::vector<T> (<vector>)",doc:`Dynamic array that can grow and shrink.

\`\`\`cpp
std::vector<int> v = {1, 2, 3};
v.push_back(4);
v.size(); // 4
\`\`\`
Complexity: O(1) amortized push_back, O(1) random access.`},map:{detail:"std::map<K,V> (<map>)",doc:'Sorted associative container (red-black tree).\n\n```cpp\nstd::map<std::string, int> m;\nm["hello"] = 1;\n```\nComplexity: O(log n) insert/find.'},unordered_map:{detail:"std::unordered_map<K,V> (<unordered_map>)",doc:'Hash table based associative container.\n\n```cpp\nstd::unordered_map<std::string, int> m;\nm["hello"] = 1;\n```\nComplexity: O(1) average insert/find.'},set:{detail:"std::set<T> (<set>)",doc:`Sorted container of unique elements (red-black tree).

Complexity: O(log n) insert/find.`},unordered_set:{detail:"std::unordered_set<T> (<unordered_set>)",doc:`Hash table based container of unique elements.

Complexity: O(1) average insert/find.`},string:{detail:"std::string (<string>)",doc:'Dynamic string of characters (alias for std::basic_string<char>).\n\n```cpp\nstd::string s = "Hello";\ns += " World";\ns.size(); // 11\n```'},array:{detail:"std::array<T,N> (<array>)",doc:"Fixed-size array container.\n\n```cpp\nstd::array<int, 3> a = {1, 2, 3};\n```"},deque:{detail:"std::deque<T> (<deque>)",doc:"Double-ended queue supporting O(1) push/pop at both ends."},list:{detail:"std::list<T> (<list>)",doc:"Doubly-linked list. O(1) insert/erase with iterator."},queue:{detail:"std::queue<T> (<queue>)",doc:"FIFO queue adapter (uses deque by default)."},stack:{detail:"std::stack<T> (<stack>)",doc:"LIFO stack adapter (uses deque by default)."},priority_queue:{detail:"std::priority_queue<T> (<queue>)",doc:"Max-heap based priority queue.\n\n```cpp\nstd::priority_queue<int> pq;\npq.push(3); pq.push(1); pq.push(2);\npq.top(); // 3\n```"},pair:{detail:"std::pair<T1,T2> (<utility>)",doc:'Holds two values of possibly different types.\n\n```cpp\nauto p = std::make_pair(1, "hello");\np.first;  // 1\np.second; // "hello"\n```'},tuple:{detail:"std::tuple<Ts...> (<tuple>)",doc:'Fixed-size collection of heterogeneous values.\n\n```cpp\nauto t = std::make_tuple(1, 2.0, "hi");\nstd::get<0>(t); // 1\n```'},optional:{detail:"std::optional<T> (<optional>) C++17",doc:"May or may not contain a value.\n\n```cpp\nstd::optional<int> opt = 42;\nif (opt) { use(*opt); }\n```"},variant:{detail:"std::variant<Ts...> (<variant>) C++17",doc:'Type-safe union.\n\n```cpp\nstd::variant<int, std::string> v = "hello";\n```'},any:{detail:"std::any (<any>) C++17",doc:"Type-safe container for single values of any type."},shared_ptr:{detail:"std::shared_ptr<T> (<memory>)",doc:"Reference-counted smart pointer. Multiple shared_ptrs can share ownership.\n\n```cpp\nauto sp = std::make_shared<MyClass>(args);\n```"},unique_ptr:{detail:"std::unique_ptr<T> (<memory>)",doc:"Exclusive-ownership smart pointer. Cannot be copied, only moved.\n\n```cpp\nauto up = std::make_unique<MyClass>(args);\n```"},weak_ptr:{detail:"std::weak_ptr<T> (<memory>)",doc:"Non-owning observer of a shared_ptr. Breaks circular references."},cout:{detail:"std::cout (<iostream>)",doc:'Standard output stream.\n\n```cpp\nstd::cout << "Hello, World!" << std::endl;\n```'},cin:{detail:"std::cin (<iostream>)",doc:"Standard input stream.\n\n```cpp\nint x;\nstd::cin >> x;\n```"},cerr:{detail:"std::cerr (<iostream>)",doc:"Standard error stream (unbuffered)."},endl:{detail:"std::endl (<iostream>)",doc:'Inserts a newline and flushes the stream. Consider using "\\n" for better performance.'},printf:{detail:"int printf(const char* fmt, ...) (<cstdio>)",doc:"C-style formatted output. Consider using std::cout or std::format (C++20) instead."},scanf:{detail:"int scanf(const char* fmt, ...) (<cstdio>)",doc:"C-style formatted input."},sort:{detail:"std::sort (<algorithm>)",doc:"Sorts elements in a range.\n\n```cpp\nstd::sort(v.begin(), v.end());\nstd::sort(v.begin(), v.end(), std::greater<int>());\n```\nComplexity: O(n log n)."},find:{detail:"std::find (<algorithm>)",doc:"Finds the first element equal to a value.\n\n```cpp\nauto it = std::find(v.begin(), v.end(), target);\n```\nComplexity: O(n)."},count:{detail:"std::count (<algorithm>)",doc:"Counts elements equal to a value.\n\n```cpp\nint c = std::count(v.begin(), v.end(), target);\n```"},transform:{detail:"std::transform (<algorithm>)",doc:"Applies a function to a range and stores results.\n\n```cpp\nstd::transform(v.begin(), v.end(), out.begin(), [](int x){ return x*2; });\n```"},accumulate:{detail:"std::accumulate (<numeric>)",doc:"Computes the sum (or fold) of a range.\n\n```cpp\nint sum = std::accumulate(v.begin(), v.end(), 0);\n```"},max:{detail:"std::max (<algorithm>)",doc:"Returns the larger of two values or the largest in an initializer list.\n\n```cpp\nint m = std::max(a, b);\nint m2 = std::max({1,2,3});\n```"},min:{detail:"std::min (<algorithm>)",doc:"Returns the smaller of two values."},swap:{detail:"std::swap (<utility>)",doc:"Exchanges values of two objects.\n\n```cpp\nstd::swap(a, b);\n```"},move:{detail:"std::move (<utility>)",doc:"Casts an expression to an rvalue reference, enabling move semantics.\n\n```cpp\nstd::string s2 = std::move(s1);\n```"},forward:{detail:"std::forward<T> (<utility>)",doc:"Perfectly forwards an argument, preserving its value category."},make_shared:{detail:"std::make_shared<T>(args...) (<memory>)",doc:"Creates a shared_ptr with a single allocation.\n\n```cpp\nauto sp = std::make_shared<Widget>(42);\n```"},make_unique:{detail:"std::make_unique<T>(args...) (<memory>) C++14",doc:"Creates a unique_ptr.\n\n```cpp\nauto up = std::make_unique<Widget>(42);\n```"},make_pair:{detail:"std::make_pair(a, b) (<utility>)",doc:"Creates a std::pair, deducing types."},make_tuple:{detail:"std::make_tuple(args...) (<tuple>)",doc:"Creates a std::tuple, deducing types."},begin:{detail:"std::begin(container)",doc:"Returns an iterator to the beginning."},end:{detail:"std::end(container)",doc:"Returns an iterator to the end."},to_string:{detail:"std::to_string(val) (<string>)",doc:"Converts a numeric value to std::string."},stoi:{detail:"std::stoi(str) (<string>)",doc:"Converts a string to int. Throws on failure."},stol:{detail:"std::stol(str) (<string>)",doc:"Converts a string to long."},stod:{detail:"std::stod(str) (<string>)",doc:"Converts a string to double."},getline:{detail:"std::getline(stream, string) (<string>)",doc:"Reads a line from a stream.\n\n```cpp\nstd::string line;\nstd::getline(std::cin, line);\n```"},assert:{detail:"assert(expr) (<cassert>)",doc:"Runtime assertion macro. Aborts program if expression is false (disabled with NDEBUG)."},thread:{detail:"std::thread (<thread>) C++11",doc:"Represents a thread of execution.\n\n```cpp\nstd::thread t(func, arg1);\nt.join();\n```"},mutex:{detail:"std::mutex (<mutex>) C++11",doc:"Mutual exclusion primitive.\n\n```cpp\nstd::mutex mtx;\nstd::lock_guard<std::mutex> lock(mtx);\n```"},atomic:{detail:"std::atomic<T> (<atomic>) C++11",doc:"Provides atomic operations on a value.\n\n```cpp\nstd::atomic<int> counter{0};\ncounter.fetch_add(1);\n```"},future:{detail:"std::future<T> (<future>) C++11",doc:"Provides a mechanism to access the result of async operations."},promise:{detail:"std::promise<T> (<future>) C++11",doc:"Provides a facility to store a value to be acquired asynchronously via a future."},async:{detail:"std::async (<future>) C++11",doc:"Runs a function asynchronously and returns a future.\n\n```cpp\nauto f = std::async(std::launch::async, compute, arg);\nf.get();\n```"}},g=[{label:"main",detail:"Main function",insertText:`int main(int argc, char* argv[]) {
	\${1:// code}
	return 0;
}`,doc:"Standard C++ main function with arguments."},{label:"main-simple",detail:"Simple main function",insertText:`int main() {
	\${1:// code}
	return 0;
}`,doc:"Simple C++ main function."},{label:"#include",detail:"Include header",insertText:"#include <${1:iostream}>",doc:"Include a standard library header."},{label:'#include""',detail:"Include local header",insertText:'#include "${1:header.h}"',doc:"Include a local/project header."},{label:"class",detail:"Class declaration",insertText:`class \${1:ClassName} {
public:
	\${1:ClassName}(\${2:});
	~\${1:ClassName}();

private:
	\${3:// members}
};`,doc:"Full class declaration with constructor and destructor."},{label:"struct",detail:"Struct declaration",insertText:"struct ${1:Name} {\n	${2:int value;}\n};",doc:"Struct declaration."},{label:"for",detail:"For loop",insertText:"for (${1:int} ${2:i} = ${3:0}; ${2:i} < ${4:n}; ++${2:i}) {\n	${5:// body}\n}",doc:"Standard for loop."},{label:"forr",detail:"Range-based for loop",insertText:"for (${1:auto}& ${2:elem} : ${3:container}) {\n	${4:// body}\n}",doc:"Range-based for loop (C++11)."},{label:"forc",detail:"Const range-based for loop",insertText:"for (const ${1:auto}& ${2:elem} : ${3:container}) {\n	${4:// body}\n}",doc:"Const range-based for loop."},{label:"while",detail:"While loop",insertText:"while (${1:condition}) {\n	${2:// body}\n}",doc:"While loop."},{label:"do-while",detail:"Do-while loop",insertText:"do {\n	${1:// body}\n} while (${2:condition});",doc:"Do-while loop (executes at least once)."},{label:"if",detail:"If statement",insertText:"if (${1:condition}) {\n	${2:// body}\n}",doc:"If statement."},{label:"ife",detail:"If-else statement",insertText:`if (\${1:condition}) {
	\${2:// then}
} else {
	\${3:// else}
}`,doc:"If-else statement."},{label:"switch",detail:"Switch statement",insertText:`switch (\${1:expr}) {
	case \${2:value}:
		\${3:// code}
		break;
	default:
		\${4:// default}
		break;
}`,doc:"Switch statement."},{label:"try-catch",detail:"Try-catch block",insertText:"try {\n	${1:// code}\n} catch (const ${2:std::exception}& ${3:e}) {\n	${4:// handle}\n}",doc:"Try-catch exception handling."},{label:"lambda",detail:"Lambda expression",insertText:"[${1:&}](${2:auto param}) {\n	${3:return param;}\n}",doc:"Lambda expression (C++11)."},{label:"template-func",detail:"Template function",insertText:"template<typename ${1:T}>\n${2:T} ${3:func}(${4:T param}) {\n	${5:return param;}\n}",doc:"Template function."},{label:"template-class",detail:"Template class",insertText:"template<typename ${1:T}>\nclass ${2:ClassName} {\npublic:\n	${2:ClassName}(${1:T} ${3:val}) : ${4:m_val}(${3:val}) {}\n\n	${1:T} get() const { return ${4:m_val}; }\n\nprivate:\n	${1:T} ${4:m_val};\n};",doc:"Template class with member."},{label:"enum-class",detail:"Scoped enum",insertText:"enum class ${1:Name} {\n	${2:Value1},\n	${3:Value2},\n	${4:Value3}\n};",doc:"Scoped enumeration (C++11)."},{label:"cout",detail:"std::cout statement",insertText:'std::cout << ${1:"Hello"} << std::endl;',doc:"Output to standard out."},{label:"cin",detail:"std::cin statement",insertText:"std::cin >> ${1:variable};",doc:"Read from standard input."},{label:"cerr",detail:"std::cerr statement",insertText:'std::cerr << ${1:"Error"} << std::endl;',doc:"Output to standard error."},{label:"vector-init",detail:"Vector initialization",insertText:"std::vector<${1:int}> ${2:vec} = {${3:1, 2, 3}};",doc:"Initialize a vector with values."},{label:"map-init",detail:"Map initialization",insertText:'std::map<${1:std::string}, ${2:int}> ${3:m} = {\n	{${4:"key"}, ${5:0}}\n};',doc:"Initialize a map."},{label:"unique-ptr",detail:"std::make_unique",insertText:"auto ${1:ptr} = std::make_unique<${2:Type}>(${3:args});",doc:"Create a unique pointer."},{label:"shared-ptr",detail:"std::make_shared",insertText:"auto ${1:ptr} = std::make_shared<${2:Type}>(${3:args});",doc:"Create a shared pointer."},{label:"guard",detail:"Include guard",insertText:`#ifndef \${1:HEADER_H}
#define \${1:HEADER_H}

\${2:// declarations}

#endif // \${1:HEADER_H}`,doc:"Header include guard."},{label:"pragma-once",detail:"#pragma once",insertText:`#pragma once

\${1:// declarations}`,doc:"Pragma once include guard (non-standard but widely supported)."},{label:"namespace",detail:"Namespace declaration",insertText:`namespace \${1:name} {

\${2:// code}

} // namespace \${1:name}`,doc:"Namespace declaration."},{label:"algo-sort",detail:"std::sort",insertText:"std::sort(${1:vec}.begin(), ${1:vec}.end()${2:});",doc:"Sort a container."},{label:"algo-find",detail:"std::find",insertText:"auto ${1:it} = std::find(${2:vec}.begin(), ${2:vec}.end(), ${3:value});\nif (${1:it} != ${2:vec}.end()) {\n	${4:// found}\n}",doc:"Find an element in a container."},{label:"fstream-read",detail:"Read file",insertText:'std::ifstream ${1:file}(${2:"filename.txt"});\nif (${1:file}.is_open()) {\n	std::string ${3:line};\n	while (std::getline(${1:file}, ${3:line})) {\n		${4:// process line}\n	}\n	${1:file}.close();\n}',doc:"Read from a file line by line."},{label:"fstream-write",detail:"Write file",insertText:'std::ofstream ${1:file}(${2:"filename.txt"});\nif (${1:file}.is_open()) {\n	${1:file} << ${3:"content"} << std::endl;\n	${1:file}.close();\n}',doc:"Write to a file."},{label:"operator<<",detail:"Stream insertion operator",insertText:"friend std::ostream& operator<<(std::ostream& ${1:os}, const ${2:ClassName}& ${3:obj}) {\n	${1:os} << ${4:obj.value};\n	return ${1:os};\n}",doc:"Overload << for std::ostream."},{label:"rule-of-five",detail:"Rule of Five",insertText:"${1:ClassName}(const ${1:ClassName}& other);                    // copy constructor\n${1:ClassName}(${1:ClassName}&& other) noexcept;                 // move constructor\n${1:ClassName}& operator=(const ${1:ClassName}& other);          // copy assignment\n${1:ClassName}& operator=(${1:ClassName}&& other) noexcept;     // move assignment\n~${1:ClassName}();                                             // destructor",doc:"The Rule of Five special member functions."},{label:"constexpr-func",detail:"Constexpr function",insertText:"constexpr ${1:int} ${2:func}(${3:int n}) {\n	${4:return n * n;}\n}",doc:"Compile-time evaluable function."},{label:"static_assert",detail:"Static assertion",insertText:'static_assert(${1:condition}, ${2:"message"});',doc:"Compile-time assertion."},{label:"concept",detail:"Concept definition (C++20)",insertText:"template<typename ${1:T}>\nconcept ${2:ConceptName} = requires(${1:T} ${3:a}) {\n	{ ${4:a.size()} } -> std::convertible_to<std::size_t>;\n};",doc:"C++20 concept definition."}],b=["#include","#define","#undef","#ifdef","#ifndef","#if","#elif","#else","#endif","#pragma","#error","#warning","#line"];function h(c){let n=[],d=c.split(`
`);for(let l=0;l<d.length;l++){let s=d[l],e=l+1,i=s.replace(/\/\/.*$/,"").replace(/"(?:[^"\\]|\\.)*"/g,'""').replace(/'(?:[^'\\]|\\.)*'/g,"''"),o=i.match(/^\s*(?:(?:static|inline|virtual|constexpr|explicit|friend|const|volatile|unsigned|signed|long|short)\s+)*([a-zA-Z_][\w:*&<>, ]*?)\s+([a-zA-Z_]\w*)\s*\(([^)]*)\)\s*(?:const)?\s*(?:noexcept)?\s*(?:override)?\s*(?:final)?\s*\{?\s*$/);if(o&&!["if","else","for","while","do","switch","catch","return","case","throw"].includes(o[2])){let u=s.indexOf(o[2])+1;n.push({name:o[2],kind:"function",returnType:o[1].trim(),params:o[3].trim(),line:e,col:u});continue}if(o=i.match(/^\s*(class|struct|enum\s+class|enum)\s+([a-zA-Z_]\w*)/),o){let u=s.indexOf(o[2])+1;n.push({name:o[2],kind:o[1].replace(/\s+/g,"_"),line:e,col:u});continue}if(o=i.match(/^\s*namespace\s+([a-zA-Z_]\w*)/),o){let u=s.indexOf(o[1])+1;n.push({name:o[1],kind:"namespace",line:e,col:u});continue}if(o=i.match(/^\s*(?:typedef\s+.+\s+([a-zA-Z_]\w*)\s*;|using\s+([a-zA-Z_]\w*)\s*=)/),o){let u=o[1]||o[2],r=s.indexOf(u)+1;n.push({name:u,kind:"typedef",line:e,col:r});continue}if(o=i.match(/^\s*#\s*define\s+([a-zA-Z_]\w*)(?:\(([^)]*)\))?\s*(.*)?/),o){let u=s.indexOf(o[1])+1;n.push({name:o[1],kind:"macro",params:o[2],value:o[3],line:e,col:u});continue}if(o=i.match(/^\s*(?:(?:static|const|constexpr|inline|extern|thread_local|volatile|unsigned|signed|long|short|auto)\s+)*([a-zA-Z_][\w:*&<>, ]+?)\s+([a-zA-Z_]\w*)\s*[=;{(]/),o&&!["if","else","for","while","do","switch","catch","return","case","throw","class","struct","enum","namespace","template","using","typedef","delete","new"].includes(o[2])&&!["public","private","protected"].includes(o[2])){let u=s.indexOf(o[2])+1;n.push({name:o[2],kind:"variable",type:o[1].trim(),line:e,col:u})}}return n}let m=[];function y(c){m=h(c.getValue());let n=document.getElementById("symbolCount");n&&(n.textContent=`Symbols: ${m.length}`)}t.languages.registerCompletionItemProvider("cpp",{triggerCharacters:[".",":","<","#",'"'],provideCompletionItems:function(c,n,d){let l=c.getValueInRange({startLineNumber:n.lineNumber,startColumn:1,endLineNumber:n.lineNumber,endColumn:n.column}),s=c.getWordUntilPosition(n),e={startLineNumber:n.lineNumber,endLineNumber:n.lineNumber,startColumn:s.startColumn,endColumn:s.endColumn},i=[];if(l.match(/^\s*#/)){b.forEach(a=>{i.push({label:a,kind:t.languages.CompletionItemKind.Keyword,insertText:a.replace("#",""),range:e,detail:"Preprocessor directive"})});let r=["iostream","vector","string","map","set","unordered_map","unordered_set","algorithm","numeric","functional","memory","cassert","cmath","cstdio","cstdlib","cstring","fstream","sstream","iomanip","iterator","stdexcept","typeinfo","type_traits","utility","tuple","array","deque","list","queue","stack","bitset","regex","chrono","thread","mutex","atomic","future","condition_variable","filesystem","optional","variant","any","span","ranges","format","concepts","coroutine","numbers"];return l.match(/#\s*include\s*</)&&r.forEach(a=>{i.push({label:a,kind:t.languages.CompletionItemKind.File,insertText:a+">",range:e,detail:`<${a}> \u2014 Standard library header`})}),{suggestions:i}}return l.match(/std\s*::\s*\w*$/)?(["cout","cin","cerr","clog","endl","string","wstring","string_view","vector","map","multimap","set","multiset","unordered_map","unordered_multimap","unordered_set","unordered_multiset","list","deque","array","queue","priority_queue","stack","pair","tuple","optional","variant","any","shared_ptr","unique_ptr","weak_ptr","make_shared","make_unique","make_pair","make_tuple","move","forward","swap","begin","end","sort","stable_sort","find","find_if","count","count_if","for_each","transform","accumulate","reduce","copy","fill","reverse","rotate","unique","remove","remove_if","replace","max","min","max_element","min_element","clamp","lower_bound","upper_bound","binary_search","next_permutation","prev_permutation","iota","gcd","lcm","distance","advance","next","prev","to_string","stoi","stol","stoll","stof","stod","getline","get","tie","thread","mutex","lock_guard","unique_lock","scoped_lock","atomic","future","promise","async","function","bind","ref","cref","numeric_limits","type_traits","runtime_error","logic_error","invalid_argument","out_of_range","overflow_error","underflow_error","exception","ifstream","ofstream","fstream","stringstream","istringstream","ostringstream","setw","setprecision","fixed","scientific","hex","dec","oct","bitset","complex","regex","smatch","regex_match","regex_search","chrono","filesystem","nullptr_t","size_t","ptrdiff_t","initializer_list","allocator","hash","equal_to","less","greater","plus","minus","multiplies","divides","modulus","negate","format","print","println","span","ranges","views"].forEach(a=>{let p=f[a];i.push({label:a,kind:p?a[0]===a[0].toUpperCase()||["vector","map","set","string","list","deque","array","queue","stack","pair","tuple","optional","variant","any","shared_ptr","unique_ptr","weak_ptr","atomic","mutex","thread","future","promise","bitset","complex","regex","function"].includes(a)?t.languages.CompletionItemKind.Class:t.languages.CompletionItemKind.Function:t.languages.CompletionItemKind.Text,insertText:a,range:e,detail:p?p.detail:`std::${a}`,documentation:p?{value:p.doc}:void 0,sortText:"0_"+a})}),{suggestions:i}):l.match(/\.\s*\w*$/)||l.match(/->\s*\w*$/)?([{label:"push_back",detail:"void push_back(const T& val)",doc:"Adds element to the end."},{label:"pop_back",detail:"void pop_back()",doc:"Removes the last element."},{label:"size",detail:"size_t size() const",doc:"Returns the number of elements."},{label:"empty",detail:"bool empty() const",doc:"Checks if the container is empty."},{label:"clear",detail:"void clear()",doc:"Removes all elements."},{label:"begin",detail:"iterator begin()",doc:"Returns iterator to the beginning."},{label:"end",detail:"iterator end()",doc:"Returns iterator to the end."},{label:"rbegin",detail:"reverse_iterator rbegin()",doc:"Returns reverse iterator to the end."},{label:"rend",detail:"reverse_iterator rend()",doc:"Returns reverse iterator to the beginning."},{label:"front",detail:"T& front()",doc:"Returns reference to the first element."},{label:"back",detail:"T& back()",doc:"Returns reference to the last element."},{label:"at",detail:"T& at(size_t pos)",doc:"Returns element at position with bounds checking."},{label:"data",detail:"T* data()",doc:"Returns pointer to the underlying array."},{label:"reserve",detail:"void reserve(size_t n)",doc:"Reserves storage capacity."},{label:"resize",detail:"void resize(size_t n)",doc:"Resizes the container."},{label:"capacity",detail:"size_t capacity() const",doc:"Returns the allocated capacity."},{label:"shrink_to_fit",detail:"void shrink_to_fit()",doc:"Reduces capacity to size."},{label:"insert",detail:"iterator insert(pos, val)",doc:"Inserts element(s) at position."},{label:"erase",detail:"iterator erase(pos)",doc:"Erases element(s) at position."},{label:"emplace_back",detail:"void emplace_back(args...)",doc:"Constructs element in-place at the end."},{label:"emplace",detail:"iterator emplace(pos, args...)",doc:"Constructs element in-place at position."},{label:"find",detail:"iterator find(key)",doc:"Finds element with given key."},{label:"count",detail:"size_t count(key)",doc:"Counts elements with given key."},{label:"contains",detail:"bool contains(key) (C++20)",doc:"Checks if container has element."},{label:"swap",detail:"void swap(other)",doc:"Swaps contents with another container."},{label:"push",detail:"void push(const T& val)",doc:"Pushes element (stack/queue)."},{label:"pop",detail:"void pop()",doc:"Removes top/front element (stack/queue)."},{label:"top",detail:"T& top()",doc:"Access top element (stack/priority_queue)."},{label:"first",detail:"T1 first",doc:"First element of pair."},{label:"second",detail:"T2 second",doc:"Second element of pair."},{label:"c_str",detail:"const char* c_str() const",doc:"Returns C-style string."},{label:"length",detail:"size_t length() const",doc:"Returns string length."},{label:"substr",detail:"string substr(pos, len)",doc:"Returns a substring."},{label:"find",detail:"size_t find(str, pos)",doc:"Finds first occurrence of substring."},{label:"rfind",detail:"size_t rfind(str, pos)",doc:"Finds last occurrence of substring."},{label:"append",detail:"string& append(str)",doc:"Appends to the string."},{label:"replace",detail:"string& replace(pos, len, str)",doc:"Replaces part of the string."},{label:"compare",detail:"int compare(str)",doc:"Compares strings."},{label:"starts_with",detail:"bool starts_with(sv) (C++20)",doc:"Checks if string starts with given prefix."},{label:"ends_with",detail:"bool ends_with(sv) (C++20)",doc:"Checks if string ends with given suffix."},{label:"get",detail:"T* get()",doc:"Returns the stored pointer (smart pointer)."},{label:"reset",detail:"void reset(ptr)",doc:"Replaces the managed object (smart pointer)."},{label:"release",detail:"T* release()",doc:"Releases ownership (unique_ptr)."},{label:"use_count",detail:"long use_count()",doc:"Returns the reference count (shared_ptr)."},{label:"lock",detail:"shared_ptr<T> lock()",doc:"Creates shared_ptr from weak_ptr."},{label:"expired",detail:"bool expired()",doc:"Checks if managed object is deleted (weak_ptr)."},{label:"has_value",detail:"bool has_value() const",doc:"Checks if optional contains a value."},{label:"value",detail:"T& value()",doc:"Returns the contained value or throws."},{label:"value_or",detail:"T value_or(default)",doc:"Returns contained value or default."},{label:"index",detail:"size_t index() const",doc:"Returns the index of the held type (variant)."},{label:"join",detail:"void join()",doc:"Waits for thread to finish."},{label:"detach",detail:"void detach()",doc:"Detaches thread."},{label:"joinable",detail:"bool joinable()",doc:"Checks if thread is joinable."},{label:"wait",detail:"void wait()",doc:"Waits for the result (future)."},{label:"is_open",detail:"bool is_open()",doc:"Checks if file stream is open."},{label:"close",detail:"void close()",doc:"Closes the file stream."},{label:"str",detail:"string str()",doc:"Returns string copy of stringstream content."},{label:"operator[]",detail:"T& operator[](index)",doc:"Access element by index/key."}].forEach(a=>{i.push({label:a.label,kind:a.label==="first"||a.label==="second"?t.languages.CompletionItemKind.Field:t.languages.CompletionItemKind.Method,insertText:a.label,range:e,detail:a.detail,documentation:{value:a.doc}})}),{suggestions:i}):(g.forEach(r=>{i.push({label:r.label,kind:t.languages.CompletionItemKind.Snippet,insertText:r.insertText,insertTextRules:t.languages.CompletionItemInsertTextRule.InsertAsSnippet,range:e,detail:r.detail,documentation:{value:r.doc},sortText:"1_"+r.label})}),["alignas","alignof","and","and_eq","asm","auto","bitand","bitor","break","case","catch","class","compl","concept","const","consteval","constexpr","constinit","const_cast","continue","co_await","co_return","co_yield","decltype","default","delete","do","dynamic_cast","else","enum","explicit","export","extern","final","for","friend","goto","if","import","inline","module","mutable","namespace","new","noexcept","not","not_eq","operator","or","or_eq","override","private","protected","public","register","reinterpret_cast","requires","return","sizeof","static","static_assert","static_cast","struct","switch","template","this","thread_local","throw","try","typedef","typeid","typename","union","using","virtual","volatile","while","xor","xor_eq"].forEach(r=>{let a=f[r];i.push({label:r,kind:t.languages.CompletionItemKind.Keyword,insertText:r,range:e,detail:a?a.detail:"Keyword",documentation:a?{value:a.doc}:void 0,sortText:"2_"+r})}),["bool","char","char8_t","char16_t","char32_t","double","float","int","long","short","signed","unsigned","void","wchar_t","int8_t","int16_t","int32_t","int64_t","uint8_t","uint16_t","uint32_t","uint64_t","size_t","ptrdiff_t","nullptr_t"].forEach(r=>{let a=f[r];i.push({label:r,kind:t.languages.CompletionItemKind.TypeParameter,insertText:r,range:e,detail:a?a.detail:"Type",documentation:a?{value:a.doc}:void 0,sortText:"3_"+r})}),m.forEach(r=>{let a;switch(r.kind){case"function":a=t.languages.CompletionItemKind.Function;break;case"class":case"struct":a=t.languages.CompletionItemKind.Class;break;case"enum":case"enum_class":a=t.languages.CompletionItemKind.Enum;break;case"namespace":a=t.languages.CompletionItemKind.Module;break;case"macro":a=t.languages.CompletionItemKind.Constant;break;case"typedef":a=t.languages.CompletionItemKind.Interface;break;default:a=t.languages.CompletionItemKind.Variable}let p=r.kind;r.returnType?p=`${r.returnType} ${r.name}(${r.params||""})`:r.type&&(p=`${r.type} ${r.name}`),i.push({label:r.name,kind:a,insertText:r.name,range:e,detail:p,documentation:{value:`Defined at line ${r.line}`},sortText:"0_"+r.name})}),{suggestions:i})}}),t.languages.registerHoverProvider("cpp",{provideHover:function(c,n){let d=c.getWordAtPosition(n);if(!d)return null;let l=d.word,s=f[l];if(s)return{range:new t.Range(n.lineNumber,d.startColumn,n.lineNumber,d.endColumn),contents:[{value:`**${s.detail}**`},{value:s.doc}]};let e=m.find(i=>i.name===l);if(e){let i="";return e.kind==="function"?i=`\`\`\`cpp
${e.returnType||""} ${e.name}(${e.params||""})
\`\`\``:e.kind==="class"||e.kind==="struct"?i=`\`\`\`cpp
${e.kind} ${e.name}
\`\`\``:e.kind==="enum"||e.kind==="enum_class"?i=`\`\`\`cpp
enum ${e.kind==="enum_class"?"class ":""}${e.name}
\`\`\``:e.kind==="namespace"?i=`\`\`\`cpp
namespace ${e.name}
\`\`\``:e.kind==="macro"?i=`\`\`\`cpp
#define ${e.name}${e.params!==void 0?"("+(e.params||"")+")":""}${e.value?" "+e.value:""}
\`\`\``:e.kind==="typedef"?i=`\`\`\`cpp
typedef/using ${e.name}
\`\`\``:e.kind==="variable"&&(i=`\`\`\`cpp
${e.type||"auto"} ${e.name}
\`\`\``),{range:new t.Range(n.lineNumber,d.startColumn,n.lineNumber,d.endColumn),contents:[{value:i},{value:`*Defined at line ${e.line}*`}]}}return null}}),t.languages.registerDefinitionProvider("cpp",{provideDefinition:function(c,n){let d=c.getWordAtPosition(n);if(!d)return null;let l=d.word,s=m.find(e=>e.name===l);return s?{uri:c.uri,range:new t.Range(s.line,s.col,s.line,s.col+s.name.length)}:null}}),t.languages.registerSignatureHelpProvider("cpp",{signatureHelpTriggerCharacters:["(",","],provideSignatureHelp:function(c,n){let l=c.getValueInRange({startLineNumber:n.lineNumber,startColumn:1,endLineNumber:n.lineNumber,endColumn:n.column}).match(/([a-zA-Z_]\w*)\s*\(([^)]*)$/);if(!l)return null;let s=l[1],i=(l[2].match(/,/g)||[]).length,o=m.find(a=>a.name===s&&a.kind==="function");if(o){let a=(o.params||"").split(",").map(p=>p.trim()).filter(Boolean);return{value:{signatures:[{label:`${o.returnType||"void"} ${o.name}(${o.params||""})`,parameters:a.map(p=>({label:p,documentation:""})),documentation:`Function defined at line ${o.line}`}],activeSignature:0,activeParameter:i},dispose:function(){}}}let r={sort:{label:"void std::sort(RandomIt first, RandomIt last, Compare comp = {})",params:[{label:"RandomIt first",documentation:"Iterator to the beginning of the range"},{label:"RandomIt last",documentation:"Iterator to the end of the range"},{label:"Compare comp",documentation:"Comparison function (optional)"}],doc:"Sorts elements in ascending order. Complexity: O(n log n)."},find:{label:"InputIt std::find(InputIt first, InputIt last, const T& value)",params:[{label:"InputIt first",documentation:"Iterator to the beginning"},{label:"InputIt last",documentation:"Iterator to the end"},{label:"const T& value",documentation:"Value to search for"}],doc:"Finds the first element equal to value."},make_shared:{label:"std::shared_ptr<T> std::make_shared<T>(Args&&... args)",params:[{label:"Args&&... args",documentation:"Arguments forwarded to constructor of T"}],doc:"Creates a shared_ptr managing a new object."},make_unique:{label:"std::unique_ptr<T> std::make_unique<T>(Args&&... args)",params:[{label:"Args&&... args",documentation:"Arguments forwarded to constructor of T"}],doc:"Creates a unique_ptr managing a new object."},printf:{label:"int printf(const char* format, ...)",params:[{label:"const char* format",documentation:"Format string"},{label:"...",documentation:"Additional arguments"}],doc:"Prints formatted output to stdout."},scanf:{label:"int scanf(const char* format, ...)",params:[{label:"const char* format",documentation:"Format string"},{label:"...",documentation:"Pointers to receiving variables"}],doc:"Reads formatted input from stdin."},accumulate:{label:"T std::accumulate(InputIt first, InputIt last, T init)",params:[{label:"InputIt first",documentation:"Iterator to beginning"},{label:"InputIt last",documentation:"Iterator to end"},{label:"T init",documentation:"Initial value for accumulation"}],doc:"Computes the sum of init and the elements in the range."},getline:{label:"istream& std::getline(istream& is, string& str, char delim = '\\n')",params:[{label:"istream& is",documentation:"Input stream"},{label:"string& str",documentation:"String to store the line"},{label:"char delim",documentation:"Delimiter character (default: newline)"}],doc:"Reads a line from the input stream."},transform:{label:"OutputIt std::transform(InputIt first, InputIt last, OutputIt d_first, UnaryOp op)",params:[{label:"InputIt first",documentation:"Iterator to beginning of input"},{label:"InputIt last",documentation:"Iterator to end of input"},{label:"OutputIt d_first",documentation:"Iterator to beginning of output"},{label:"UnaryOp op",documentation:"Unary operation to apply"}],doc:"Applies the given function to a range and stores the result."}}[s];return r?{value:{signatures:[{label:r.label,parameters:r.params,documentation:r.doc}],activeSignature:0,activeParameter:i},dispose:function(){}}:null}}),t.languages.registerDocumentSymbolProvider("cpp",{provideDocumentSymbols:function(c){return y(c),m.map(n=>{let d;switch(n.kind){case"function":d=t.languages.SymbolKind.Function;break;case"class":d=t.languages.SymbolKind.Class;break;case"struct":d=t.languages.SymbolKind.Struct;break;case"enum":case"enum_class":d=t.languages.SymbolKind.Enum;break;case"namespace":d=t.languages.SymbolKind.Namespace;break;case"macro":d=t.languages.SymbolKind.Constant;break;case"typedef":d=t.languages.SymbolKind.Interface;break;case"variable":d=t.languages.SymbolKind.Variable;break;default:d=t.languages.SymbolKind.Variable}let l=new t.Range(n.line,n.col,n.line,n.col+n.name.length);return{name:n.name,detail:n.kind,kind:d,range:l,selectionRange:l}})}}),t.languages.registerCodeActionProvider("cpp",{provideCodeActions:function(c,n,d){let l=[],s=c.getLineContent(n.startLineNumber);s.match(/[^;{}\s:\/]\s*$/)&&!s.match(/^\s*#/)&&!s.match(/^\s*(\/\/|\/\*|\*)/)&&!s.match(/\{\s*$/)&&!s.match(/^\s*(public|private|protected|case|default)\s*:/)&&s.match(/^\s*(if|else|for|while|do|switch|try|catch)\b/);let e=c.getWordAtPosition({lineNumber:n.startLineNumber,column:n.startColumn});if(e&&["vector","map","set","string","cout","cin","endl","array","deque","list","pair","tuple","optional","variant","shared_ptr","unique_ptr","sort","find","unordered_map","unordered_set","queue","stack","priority_queue"].includes(e.word)){let u=c.getLineContent(n.startLineNumber).substring(0,e.startColumn-1);!u.endsWith("std::")&&!u.endsWith("::")&&l.push({title:`Add std:: prefix \u2192 std::${e.word}`,kind:"quickfix",edit:{edits:[{resource:c.uri,textEdit:{range:new t.Range(n.startLineNumber,e.startColumn,n.startLineNumber,e.endColumn),text:`std::${e.word}`},versionId:c.getVersionId()}]}})}return{actions:l,dispose:function(){}}}}),t.languages.registerFoldingRangeProvider("cpp",{provideFoldingRanges:function(c){let n=[],d=c.getLinesContent(),l=[];for(let s=0;s<d.length;s++){let e=d[s];if(e.match(/^\s*#pragma\s+region/)&&l.push({start:s+1,kind:t.languages.FoldingRangeKind.Region}),e.match(/^\s*#pragma\s+endregion/)&&l.length>0){let i=l.pop();i.kind===t.languages.FoldingRangeKind.Region&&n.push({start:i.start,end:s+1,kind:i.kind})}if(e.match(/\/\*/)&&!e.match(/\*\//)&&l.push({start:s+1,kind:t.languages.FoldingRangeKind.Comment}),e.match(/\*\//)&&l.length>0&&l[l.length-1].kind===t.languages.FoldingRangeKind.Comment){let i=l.pop();n.push({start:i.start,end:s+1,kind:i.kind})}}return n}})};export{_ as default};
