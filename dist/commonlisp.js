var q=c=>{let L=["block","catch","eval-when","flet","function","go","if","labels","let","let*","load-time-value","locally","macrolet","multiple-value-call","multiple-value-prog1","progn","progv","quote","return-from","setq","symbol-macrolet","tagbody","the","throw","unwind-protect"],R=["defun","defmacro","defvar","defparameter","defconstant","defclass","defmethod","defgeneric","defstruct","defpackage","deftype","define-condition","define-method-combination","define-compiler-macro","define-modify-macro","define-setf-expander","define-symbol-macro"],T=["lambda","when","unless","cond","case","ecase","ccase","typecase","etypecase","ctypecase","and","or","do","do*","dolist","dotimes","loop","prog","prog*","prog1","prog2","multiple-value-bind","multiple-value-list","multiple-value-setq","nth-value","destructuring-bind","with-open-file","with-open-stream","with-output-to-string","with-input-from-string","with-slots","with-accessors","with-standard-io-syntax","with-compilation-unit","with-hash-table-iterator","with-package-iterator","with-simple-restart","with-condition-restarts","handler-case","handler-bind","restart-case","restart-bind","ignore-errors","check-type","assert","setf","psetf","psetq","push","pop","pushnew","incf","decf","rotatef","shiftf","return","loop-finish","in-package","use-package","export","import","declaim","declare","proclaim","time","trace","untrace","step","describe","inspect","print-unreadable-object","formatter","defsetf","pprint-logical-block","pprint-exit-if-list-exhausted","decf","remf"],v=["car","cdr","cons","list","list*","append","nconc","reverse","nreverse","length","first","second","third","fourth","fifth","sixth","seventh","eighth","ninth","tenth","rest","last","butlast","nbutlast","nth","nthcdr","elt","caar","cadr","cdar","cddr","caaar","caadr","cadar","caddr","cdaar","cdadr","cddar","cdddr","copy-list","copy-tree","copy-alist","ldiff","tailp","list-length","make-list","revappend","nreconc","member","member-if","member-if-not","assoc","assoc-if","assoc-if-not","rassoc","rassoc-if","rassoc-if-not","acons","pairlis","subst","subst-if","nsubst","sublis","nsublis","adjoin","union","nunion","intersection","nintersection","set-difference","nset-difference","set-exclusive-or","nset-exclusive-or","subsetp","mapcar","maplist","mapc","mapl","mapcan","mapcon","reduce","count","count-if","count-if-not","find","find-if","find-if-not","position","position-if","position-if-not","search","mismatch","remove","remove-if","remove-if-not","delete","delete-if","delete-if-not","remove-duplicates","delete-duplicates","substitute","substitute-if","substitute-if-not","nsubstitute","nsubstitute-if","nsubstitute-if-not","sort","stable-sort","merge","concatenate","subseq","fill","replace","every","some","notevery","notany","map-into","coerce","map","abs","max","min","gcd","lcm","floor","ceiling","truncate","round","mod","rem","expt","sqrt","isqrt","exp","log","sin","cos","tan","asin","acos","atan","sinh","cosh","tanh","asinh","acosh","atanh","random","make-random-state","float","rational","rationalize","numerator","denominator","realpart","imagpart","complex","conjugate","phase","ash","logand","logior","logxor","lognot","logbitp","logcount","integer-length","byte","ldb","dpb","parse-integer","null","atom","listp","consp","endp","numberp","integerp","floatp","rationalp","realp","complexp","zerop","plusp","minusp","evenp","oddp","symbolp","keywordp","packagep","stringp","characterp","vectorp","arrayp","bit-vector-p","functionp","compiled-function-p","hash-table-p","pathnamep","streamp","typep","subtypep","equal","equalp","eq","eql","not","identity","complement","constantly","boundp","fboundp","special-operator-p","macro-function","constantp","alpha-char-p","alphanumericp","digit-char-p","upper-case-p","lower-case-p","both-case-p","graphic-char-p","standard-char-p","char=","char/=","char<","char>","char<=","char>=","char-equal","char-not-equal","char-lessp","char-greaterp","string=","string/=","string<","string>","string<=","string>=","string-equal","string-not-equal","string-lessp","string-greaterp","string","string-upcase","string-downcase","string-capitalize","nstring-upcase","nstring-downcase","nstring-capitalize","string-trim","string-left-trim","string-right-trim","char-code","code-char","char-name","name-char","char-upcase","char-downcase","digit-char","make-string","char","intern","gensym","gentemp","make-symbol","symbol-name","symbol-package","symbol-value","symbol-function","symbol-plist","get","remprop","getf","make-array","aref","array-rank","array-dimensions","array-dimension","array-total-size","array-element-type","adjustable-array-p","adjust-array","array-displacement","vector","vector-push","vector-push-extend","vector-pop","fill-pointer","svref","make-sequence","make-hash-table","gethash","remhash","maphash","clrhash","hash-table-count","hash-table-size","hash-table-test","sxhash","format","print","prin1","princ","write","pprint","terpri","fresh-line","write-char","write-string","write-line","write-to-string","prin1-to-string","princ-to-string","read","read-line","read-char","read-char-no-hang","peek-char","unread-char","read-from-string","read-byte","write-byte","open","close","make-string-input-stream","make-string-output-stream","get-output-stream-string","input-stream-p","output-stream-p","interactive-stream-p","force-output","finish-output","clear-output","listen","clear-input","file-position","file-length","pathname","make-pathname","pathname-name","pathname-type","pathname-directory","merge-pathnames","namestring","enough-namestring","directory","probe-file","truename","file-write-date","rename-file","delete-file","ensure-directories-exist","load","compile-file","compile","make-instance","slot-value","slot-boundp","slot-makunbound","class-of","class-name","find-class","change-class","initialize-instance","reinitialize-instance","shared-initialize","slot-exists-p","call-next-method","next-method-p","compute-applicable-methods","error","cerror","warn","signal","make-condition","invoke-restart","invoke-restart-interactively","find-restart","compute-restarts","abort","continue","muffle-warning","store-value","use-value","invoke-debugger","break","funcall","apply","values","values-list","type-of","find-package","list-all-packages","package-name","find-symbol","do-symbols","do-external-symbols","do-all-symbols","make-package","delete-package","rename-package","shadow","shadowing-import","unexport","unintern","get-universal-time","get-decoded-time","decode-universal-time","encode-universal-time","get-internal-real-time","get-internal-run-time","sleep","room","lisp-implementation-type","lisp-implementation-version","documentation","1+","1-","+","-","*","/","=","<",">","<=",">=","/="],w=["t","nil","pi","most-positive-fixnum","most-negative-fixnum","most-positive-long-float","most-negative-long-float","most-positive-double-float","most-negative-double-float","most-positive-single-float","most-negative-single-float","most-positive-short-float","most-negative-short-float","double-float-epsilon","single-float-epsilon","long-float-epsilon","short-float-epsilon","boole-1","boole-2","boole-and","boole-andc1","boole-andc2","boole-c1","boole-c2","boole-clr","boole-eqv","boole-ior","boole-nand","boole-nor","boole-orc1","boole-orc2","boole-set","boole-xor","call-arguments-limit","lambda-parameters-limit","multiple-values-limit","array-rank-limit","array-dimension-limit","array-total-size-limit","char-code-limit","internal-time-units-per-second","lambda-list-keywords"],k=[...L,...R,...T],A={if:{s:"(if test then [else]) \u2192 result",d:"Evaluates test. If non-NIL, evaluates and returns then; otherwise evaluates else (defaults to NIL).",e:'(if (> x 0) "positive" "non-positive")'},let:{s:"(let ((var init) ...) declaration* body*) \u2192 result*",d:"Evaluates inits in parallel, binds vars, then evaluates body forms sequentially.",e:`(let ((x 1) (y 2))
  (+ x y)) ;=> 3`},"let*":{s:"(let* ((var init) ...) declaration* body*) \u2192 result*",d:"Like LET but binds sequentially \u2014 each init can refer to previous bindings.",e:`(let* ((x 1) (y (+ x 1)))
  y) ;=> 2`},progn:{s:"(progn form*) \u2192 result*",d:"Evaluates forms sequentially; returns the values of the last form.",e:'(progn (print "a") (print "b") 42) ;=> 42'},block:{s:"(block name form*) \u2192 result*",d:"Establishes a named block. RETURN-FROM can exit it early.",e:`(block done
  (return-from done 42)
  (print "never")) ;=> 42`},"return-from":{s:"(return-from name [result])",d:"Returns from the innermost enclosing BLOCK named name.",e:"(block nil (return-from nil 42))"},tagbody:{s:"(tagbody {tag | statement}*) \u2192 NIL",d:"Establishes tags as targets for GO. Used for low-level iteration.",e:`(tagbody
  (setq i 0)
 top
  (when (>= i 5) (go end))
  (print i)
  (incf i)
  (go top)
 end)`},go:{s:"(go tag)",d:"Transfers control to the specified tag in the enclosing TAGBODY.",e:"(go top)"},catch:{s:"(catch tag form*) \u2192 result*",d:"Establishes a catch point. THROW with matching tag exits here.",e:`(catch 'done
  (throw 'done 42)) ;=> 42`},throw:{s:"(throw tag result)",d:"Transfers control to the matching CATCH, returning result.",e:"(throw 'done 42)"},"unwind-protect":{s:"(unwind-protect protected cleanup*) \u2192 result*",d:"Evaluates protected form; cleanup forms always execute, even on non-local exit.",e:`(unwind-protect
  (do-something)
  (cleanup))`},setq:{s:"(setq {var form}*) \u2192 result",d:"Assigns values to variables sequentially. Returns the last value.",e:"(setq x 1 y 2) ;=> 2"},quote:{s:"(quote object)  or  'object",d:"Returns object without evaluating it.",e:"'(1 2 3) ;=> (1 2 3)"},function:{s:"(function name)  or  #'name",d:"Returns the function object named by name.",e:"(mapcar #'1+ '(1 2 3)) ;=> (2 3 4)"},flet:{s:"(flet ((name lambda-list body*)*) form*) \u2192 result*",d:"Binds local functions. The functions cannot reference each other.",e:`(flet ((double (x) (* 2 x)))
  (double 21)) ;=> 42`},labels:{s:"(labels ((name lambda-list body*)*) form*) \u2192 result*",d:"Like FLET but the local functions can be mutually recursive.",e:`(labels ((even? (n) (or (zerop n) (odd? (1- n))))
         (odd? (n) (and (plusp n) (even? (1- n)))))
  (even? 10)) ;=> T`},"eval-when":{s:"(eval-when (situation*) body*) \u2192 result*",d:"Controls when body is evaluated: :compile-toplevel, :load-toplevel, :execute.",e:`(eval-when (:compile-toplevel :load-toplevel :execute)
  (defvar *x* 42))`},the:{s:"(the type form) \u2192 result*",d:"Declares that form returns values of the specified type.",e:"(the fixnum (+ 1 2))"},locally:{s:"(locally declaration* form*) \u2192 result*",d:"Evaluates forms in a lexical environment with the given declarations.",e:`(locally
  (declare (optimize (speed 3)))
  (heavy-computation))`},"multiple-value-call":{s:"(multiple-value-call function form*) \u2192 result*",d:"Calls function with all values produced by each form as arguments.",e:"(multiple-value-call #'+ (floor 5 3) (floor 7 2)) ;=> 7"},defun:{s:"(defun name lambda-list [doc] declaration* body*) \u2192 name",d:"Defines a named function.",e:`(defun factorial (n)
  "Compute N factorial."
  (if (<= n 1) 1
      (* n (factorial (1- n)))))`},defmacro:{s:"(defmacro name lambda-list [doc] declaration* body*) \u2192 name",d:"Defines a macro.",e:"(defmacro with-gensyms ((&rest names) &body body)\n  `(let ,(mapcar (lambda (n) `(,n (gensym))) names)\n     ,@body))"},defvar:{s:"(defvar name [initial-value [doc]]) \u2192 name",d:"Defines a special (dynamic) variable. Only sets value if unbound.",e:"(defvar *count* 0)"},defparameter:{s:"(defparameter name initial-value [doc]) \u2192 name",d:"Defines a special variable. Always sets the value.",e:"(defparameter *max-retries* 3)"},defconstant:{s:"(defconstant name value [doc]) \u2192 name",d:"Defines a named constant.",e:"(defconstant +golden-ratio+ 1.618033988749895d0)"},defclass:{s:"(defclass name (superclass*) (slot-spec*) class-option*) \u2192 class",d:"Defines a CLOS class with slots and inheritance.",e:`(defclass person ()
  ((name :initarg :name
         :accessor person-name)
   (age  :initarg :age
         :accessor person-age
         :initform 0)))`},defmethod:{s:"(defmethod name qualifier* specialized-lambda-list body*) \u2192 method",d:"Defines a method on a generic function.",e:`(defmethod greet ((p person))
  (format nil "Hello, ~A!" (person-name p)))`},defgeneric:{s:"(defgeneric name lambda-list option*) \u2192 generic-function",d:"Defines a generic function.",e:`(defgeneric area (shape)
  (:documentation "Compute the area."))`},defstruct:{s:"(defstruct name-and-options slot-description*) \u2192 name",d:"Defines a structure type with auto-generated constructor, copier, predicate, and accessors.",e:`(defstruct point
  (x 0.0 :type single-float)
  (y 0.0 :type single-float))`},defpackage:{s:"(defpackage name option*) \u2192 package",d:"Defines or modifies a package.",e:`(defpackage :my-app
  (:use :cl)
  (:export :main :run))`},deftype:{s:"(deftype name lambda-list body*) \u2192 name",d:"Defines a derived type specifier.",e:`(deftype positive-integer ()
  '(integer 1 *))`},"define-condition":{s:"(define-condition name (parent*) (slot*) option*) \u2192 name",d:"Defines a condition type for the condition system.",e:`(define-condition my-error (error)
  ((reason :initarg :reason :reader error-reason))
  (:report (lambda (c s)
             (format s "Error: ~A" (error-reason c)))))`},lambda:{s:"(lambda lambda-list body*) \u2192 function",d:"Creates an anonymous function.",e:"(funcall (lambda (x y) (+ x y)) 3 4) ;=> 7"},when:{s:"(when test body*) \u2192 result*",d:"If test is non-NIL, evaluates body forms. Otherwise returns NIL.",e:`(when (> x 0)
  (print "positive")
  x)`},unless:{s:"(unless test body*) \u2192 result*",d:"If test is NIL, evaluates body forms. Otherwise returns NIL.",e:`(unless (zerop denom)
  (/ num denom))`},cond:{s:"(cond (test form*)* ) \u2192 result*",d:"Evaluates tests in order. For the first non-NIL test, evaluates its forms.",e:`(cond
  ((< n 0) 'negative)
  ((= n 0) 'zero)
  (t 'positive))`},case:{s:"(case keyform (keys form*)* [(otherwise form*)]) \u2192 result*",d:"Dispatches on the value of keyform using EQL comparison.",e:`(case day
  ((:mon :tue :wed :thu :fri) :weekday)
  ((:sat :sun) :weekend)
  (otherwise :unknown))`},ecase:{s:"(ecase keyform (keys form*)*) \u2192 result*",d:"Like CASE but signals an error if no clause matches.",e:`(ecase x
  (1 "one")
  (2 "two"))`},typecase:{s:"(typecase keyform (type form*)* [(otherwise form*)]) \u2192 result*",d:"Dispatches on the type of keyform.",e:`(typecase x
  (integer "int")
  (string "str")
  (otherwise "other"))`},and:{s:"(and form*) \u2192 result*",d:"Short-circuit logical AND. Returns NIL on first NIL, or the last value.",e:`(and 1 2 3) ;=> 3
(and 1 nil 3) ;=> NIL`},or:{s:"(or form*) \u2192 result*",d:"Short-circuit logical OR. Returns the first non-NIL value, or NIL.",e:"(or nil nil 3) ;=> 3"},do:{s:"(do ((var init [step])*) (end-test result*) body*) \u2192 result*",d:"General iteration. Steps variables, tests for termination.",e:`(do ((i 0 (1+ i))
     (sum 0))
    ((> i 10) sum)
  (incf sum i))`},dolist:{s:"(dolist (var list [result]) body*) \u2192 result",d:"Iterates var over elements of list.",e:`(dolist (x '(1 2 3))
  (print x))`},dotimes:{s:"(dotimes (var count [result]) body*) \u2192 result",d:"Iterates var from 0 below count.",e:`(dotimes (i 10)
  (print i))`},loop:{s:"(loop clause*) \u2192 result*",d:"The LOOP macro \u2014 a powerful iteration facility with its own sub-language. Supports FOR, COLLECT, SUM, COUNT, WHILE, UNTIL, DO, WITH, FINALLY, and more.",e:`(loop for i from 1 to 10
      when (evenp i)
      collect i)
;=> (2 4 6 8 10)`},"multiple-value-bind":{s:"(multiple-value-bind (var*) values-form body*) \u2192 result*",d:"Binds vars to the multiple values returned by values-form.",e:`(multiple-value-bind (q r) (floor 17 5)
  (list q r)) ;=> (3 2)`},"destructuring-bind":{s:"(destructuring-bind lambda-list expression body*) \u2192 result*",d:"Binds variables to a tree structure matching lambda-list.",e:`(destructuring-bind (a (b c) &rest d)
    '(1 (2 3) 4 5)
  (list a b c d)) ;=> (1 2 3 (4 5))`},"handler-case":{s:"(handler-case form (type ([var]) body*)*) \u2192 result*",d:"Evaluates form. If a condition of type is signaled, executes the matching handler.",e:`(handler-case
    (/ 1 0)
  (division-by-zero (c)
    (format nil "Caught: ~A" c)))`},"handler-bind":{s:"(handler-bind ((type handler)*) body*) \u2192 result*",d:"Like HANDLER-CASE but handler runs without unwinding the stack.",e:`(handler-bind
    ((error (lambda (c) (invoke-restart 'continue))))
  (cerror "Continue" "Oops"))`},"restart-case":{s:"(restart-case form (name lambda-list option* body*)*) \u2192 result*",d:"Establishes restarts around form.",e:`(restart-case
    (error "Failed")
  (retry () (do-it-again))
  (skip () nil))`},"ignore-errors":{s:"(ignore-errors form*) \u2192 result*, condition",d:"Evaluates forms; if an error occurs, returns NIL and the condition.",e:`(ignore-errors (/ 1 0))
;=> NIL, #<DIVISION-BY-ZERO>`},setf:{s:"(setf {place value}*) \u2192 value",d:"Generalized assignment. Sets each place to its value.",e:`(setf (car x) 99)
(setf (gethash :key table) "val")`},push:{s:"(push item place) \u2192 new-list",d:"Conses item onto the list stored in place.",e:"(push 1 mylist) ; mylist is now (1 ...)"},pop:{s:"(pop place) \u2192 element",d:"Removes and returns the first element of the list in place.",e:"(pop mylist) ;=> first element"},incf:{s:"(incf place [delta]) \u2192 new-value",d:"Increments place by delta (default 1).",e:`(incf x)    ; x = x + 1
(incf x 10) ; x = x + 10`},decf:{s:"(decf place [delta]) \u2192 new-value",d:"Decrements place by delta (default 1).",e:"(decf x)"},"with-open-file":{s:"(with-open-file (stream path option*) body*) \u2192 result*",d:"Opens a file, binds stream, evaluates body, ensures the file is closed.",e:`(with-open-file (s "data.txt"
                 :direction :output
                 :if-exists :supersede)
  (write-line "Hello" s))`},"with-output-to-string":{s:"(with-output-to-string (var) body*) \u2192 string",d:"Collects output written to var into a string.",e:`(with-output-to-string (s)
  (format s "~A + ~A = ~A" 1 2 3))
;=> "1 + 2 = 3"`},"with-slots":{s:"(with-slots (slot*) instance body*) \u2192 result*",d:"Provides direct access to slots of instance as local variables.",e:`(with-slots (name age) person
  (format t "~A is ~D" name age))`},"check-type":{s:"(check-type place type [string]) \u2192 NIL",d:"Signals a correctable error if place is not of type.",e:"(check-type x integer)"},assert:{s:"(assert test [(place*) [datum arg*]]) \u2192 NIL",d:"Signals a correctable error if test is NIL.",e:'(assert (>= x 0) (x) "X must be non-negative: ~D" x)'},"in-package":{s:"(in-package name) \u2192 package",d:"Sets *PACKAGE* to the named package.",e:"(in-package :cl-user)"},time:{s:"(time form) \u2192 result*",d:"Evaluates form and prints timing information.",e:"(time (fibonacci 30))"},return:{s:"(return [result]) \u2192 |",d:"Returns from the innermost enclosing NIL block (e.g., DO, DOLIST, LOOP).",e:`(dolist (x list)
  (when (> x 10) (return x)))`},"print-unreadable-object":{s:"(print-unreadable-object (obj stream &key type identity) body*) \u2192 NIL",d:"Prints #<...> around body output.",e:`(defmethod print-object ((p person) s)
  (print-unreadable-object (p s :type t)
    (format s "~A" (person-name p))))`},rotatef:{s:"(rotatef place*) \u2192 NIL",d:"Rotates values left among places.",e:"(rotatef a b c) ; a\u2190b, b\u2190c, c\u2190a"},shiftf:{s:"(shiftf place* newvalue) \u2192 old-first",d:"Shifts values left; rightmost gets newvalue.",e:"(shiftf a b 0) ; old a returned, a\u2190b, b\u21900"},psetf:{s:"(psetf {place value}*) \u2192 NIL",d:"Like SETF but all values are computed before any assignment.",e:"(psetf x y y x) ; swap x and y"},car:{s:"(car list) \u2192 object",d:"Returns the first element of a cons cell.",e:"(car '(1 2 3)) ;=> 1"},cdr:{s:"(cdr list) \u2192 object",d:"Returns the rest of a cons cell (everything after the first).",e:"(cdr '(1 2 3)) ;=> (2 3)"},cons:{s:"(cons object1 object2) \u2192 cons",d:"Creates a new cons cell.",e:`(cons 1 '(2 3)) ;=> (1 2 3)
(cons 1 2) ;=> (1 . 2)`},list:{s:"(list object*) \u2192 list",d:"Creates a proper list from arguments.",e:"(list 1 2 3) ;=> (1 2 3)"},"list*":{s:"(list* object+ ) \u2192 object",d:"Like LIST but the last argument is the tail.",e:"(list* 1 2 '(3 4)) ;=> (1 2 3 4)"},append:{s:"(append list*) \u2192 list",d:"Concatenates lists. Last argument is used as the tail.",e:"(append '(1 2) '(3 4)) ;=> (1 2 3 4)"},reverse:{s:"(reverse sequence) \u2192 sequence",d:"Returns a new sequence with elements in reverse order.",e:"(reverse '(1 2 3)) ;=> (3 2 1)"},length:{s:"(length sequence) \u2192 integer",d:"Number of elements in the sequence.",e:`(length '(a b c)) ;=> 3
(length "hello") ;=> 5`},nth:{s:"(nth n list) \u2192 object",d:"Returns the nth element (0-indexed).",e:"(nth 2 '(a b c d)) ;=> C"},last:{s:"(last list &optional n) \u2192 tail",d:"Returns the last n conses of list (default 1).",e:"(last '(1 2 3)) ;=> (3)"},first:{s:"(first list) \u2192 object",d:"Same as CAR.",e:"(first '(a b c)) ;=> A"},rest:{s:"(rest list) \u2192 object",d:"Same as CDR.",e:"(rest '(a b c)) ;=> (B C)"},cadr:{s:"(cadr list) \u2192 object",d:"(car (cdr list)) \u2014 the second element.",e:"(cadr '(1 2 3)) ;=> 2"},mapcar:{s:"(mapcar function list+) \u2192 list",d:"Applies function to successive elements; returns list of results.",e:"(mapcar #'1+ '(1 2 3)) ;=> (2 3 4)"},mapc:{s:"(mapc function list+) \u2192 first-list",d:"Like MAPCAR but for side effects only; returns the first list.",e:"(mapc #'print '(1 2 3))"},mapcan:{s:"(mapcan function list+) \u2192 list",d:"Like MAPCAR but NCONCs results together.",e:`(mapcan (lambda (x) (when (evenp x) (list x)))
        '(1 2 3 4)) ;=> (2 4)`},reduce:{s:"(reduce function sequence &key key start end initial-value from-end) \u2192 result",d:"Reduces sequence by applying function pairwise.",e:"(reduce #'+ '(1 2 3 4)) ;=> 10"},"remove-if":{s:"(remove-if predicate sequence &key key start end count from-end) \u2192 sequence",d:"Returns a copy of sequence without elements satisfying predicate.",e:"(remove-if #'evenp '(1 2 3 4)) ;=> (1 3)"},"remove-if-not":{s:"(remove-if-not predicate sequence ...) \u2192 sequence",d:"Keeps only elements satisfying predicate.",e:"(remove-if-not #'evenp '(1 2 3 4)) ;=> (2 4)"},find:{s:"(find item sequence &key key test start end from-end) \u2192 element",d:"Returns the first element matching item, or NIL.",e:"(find 3 '(1 2 3 4)) ;=> 3"},"find-if":{s:"(find-if predicate sequence &key key start end from-end) \u2192 element",d:"Returns the first element satisfying predicate.",e:"(find-if #'evenp '(1 2 3 4)) ;=> 2"},position:{s:"(position item sequence &key key test start end from-end) \u2192 index",d:"Returns the index of the first match, or NIL.",e:'(position #\\l "hello") ;=> 2'},count:{s:"(count item sequence &key key test start end) \u2192 integer",d:"Counts occurrences of item in sequence.",e:"(count 3 '(1 3 3 2 3)) ;=> 3"},sort:{s:"(sort sequence predicate &key key) \u2192 sequence",d:"Destructively sorts sequence.",e:"(sort (list 3 1 4 1 5) #'<) ;=> (1 1 3 4 5)"},"stable-sort":{s:"(stable-sort sequence predicate &key key) \u2192 sequence",d:"Stable destructive sort.",e:"(stable-sort (copy-seq data) #'< :key #'second)"},concatenate:{s:"(concatenate result-type sequence*) \u2192 sequence",d:"Concatenates sequences into a new sequence of the given type.",e:`(concatenate 'string "Hello" " " "World") ;=> "Hello World"`},subseq:{s:"(subseq sequence start &optional end) \u2192 sequence",d:"Returns a subsequence.",e:'(subseq "Hello World" 0 5) ;=> "Hello"'},every:{s:"(every predicate sequence+) \u2192 boolean",d:"Returns T if predicate is true for all elements.",e:"(every #'numberp '(1 2 3)) ;=> T"},some:{s:"(some predicate sequence+) \u2192 result",d:"Returns the first non-NIL result of predicate, or NIL.",e:"(some #'evenp '(1 3 4 5)) ;=> T"},coerce:{s:"(coerce object type) \u2192 result",d:"Coerces object to the specified type.",e:`(coerce "hello" 'list) ;=> (#\\h #\\e #\\l #\\l #\\o)`},member:{s:"(member item list &key key test test-not) \u2192 tail",d:"Returns the tail of list starting with the first match.",e:"(member 3 '(1 2 3 4)) ;=> (3 4)"},assoc:{s:"(assoc item alist &key key test) \u2192 entry",d:"Finds the first pair in alist whose car matches item.",e:"(assoc 'b '((a 1) (b 2) (c 3))) ;=> (B 2)"},funcall:{s:"(funcall function arg*) \u2192 result*",d:"Calls function with the given arguments.",e:"(funcall #'+ 1 2 3) ;=> 6"},apply:{s:"(apply function arg* args-list) \u2192 result*",d:"Like FUNCALL but the last argument is spread as individual args.",e:`(apply #'+ '(1 2 3)) ;=> 6
(apply #'+ 1 2 '(3)) ;=> 6`},values:{s:"(values object*) \u2192 object*",d:"Returns multiple values.",e:"(values 1 2 3)"},"values-list":{s:"(values-list list) \u2192 values*",d:"Returns the elements of list as multiple values.",e:"(values-list '(1 2 3))"},null:{s:"(null object) \u2192 boolean",d:"Returns T if object is NIL.",e:`(null '()) ;=> T
(null nil) ;=> T`},atom:{s:"(atom object) \u2192 boolean",d:"Returns T if object is not a cons.",e:`(atom 42) ;=> T
(atom '(1)) ;=> NIL`},listp:{s:"(listp object) \u2192 boolean",d:"Returns T if object is a list (cons or NIL).",e:`(listp '(1 2)) ;=> T
(listp nil) ;=> T`},consp:{s:"(consp object) \u2192 boolean",d:"Returns T if object is a cons cell.",e:`(consp '(1 2)) ;=> T
(consp nil) ;=> NIL`},numberp:{s:"(numberp object) \u2192 boolean",d:"Returns T if object is a number.",e:"(numberp 42) ;=> T"},integerp:{s:"(integerp object) \u2192 boolean",d:"Returns T if object is an integer.",e:"(integerp 42) ;=> T"},floatp:{s:"(floatp object) \u2192 boolean",d:"Returns T if object is a float.",e:"(floatp 3.14) ;=> T"},stringp:{s:"(stringp object) \u2192 boolean",d:"Returns T if object is a string.",e:'(stringp "hi") ;=> T'},symbolp:{s:"(symbolp object) \u2192 boolean",d:"Returns T if object is a symbol.",e:"(symbolp 'foo) ;=> T"},characterp:{s:"(characterp object) \u2192 boolean",d:"Returns T if object is a character.",e:"(characterp #\\a) ;=> T"},functionp:{s:"(functionp object) \u2192 boolean",d:"Returns T if object is a function.",e:"(functionp #'car) ;=> T"},typep:{s:"(typep object type) \u2192 boolean",d:"Returns T if object is of the specified type.",e:"(typep 42 'integer) ;=> T"},zerop:{s:"(zerop number) \u2192 boolean",d:"Returns T if number is zero.",e:"(zerop 0) ;=> T"},plusp:{s:"(plusp number) \u2192 boolean",d:"Returns T if number is positive.",e:"(plusp 5) ;=> T"},minusp:{s:"(minusp number) \u2192 boolean",d:"Returns T if number is negative.",e:"(minusp -3) ;=> T"},evenp:{s:"(evenp integer) \u2192 boolean",d:"Returns T if integer is even.",e:"(evenp 4) ;=> T"},oddp:{s:"(oddp integer) \u2192 boolean",d:"Returns T if integer is odd.",e:"(oddp 3) ;=> T"},not:{s:"(not x) \u2192 boolean",d:"Returns T if x is NIL, NIL otherwise. Same as NULL.",e:"(not nil) ;=> T"},eq:{s:"(eq x y) \u2192 boolean",d:"True if x and y are the identical object (pointer equality).",e:"(eq 'a 'a) ;=> T"},eql:{s:"(eql x y) \u2192 boolean",d:"Like EQ but also compares numbers by type+value and characters.",e:"(eql 42 42) ;=> T"},equal:{s:"(equal x y) \u2192 boolean",d:"Structural equality for conses, strings, bit-vectors, pathnames.",e:"(equal '(1 2) '(1 2)) ;=> T"},equalp:{s:"(equalp x y) \u2192 boolean",d:"Like EQUAL but case-insensitive for strings, numeric for numbers.",e:'(equalp "ABC" "abc") ;=> T'},identity:{s:"(identity object) \u2192 object",d:"Returns its argument. Useful as a default function argument.",e:"(identity 42) ;=> 42"},complement:{s:"(complement function) \u2192 function",d:"Returns a function that is the boolean complement.",e:"(remove-if (complement #'alpha-char-p) str)"},constantly:{s:"(constantly value) \u2192 function",d:"Returns a function that always returns value.",e:"(mapcar (constantly 0) list)"},"+":{s:"(+ number*) \u2192 sum",d:"Returns the sum. With no args returns 0.",e:"(+ 1 2 3) ;=> 6"},"-":{s:"(- number+) \u2192 difference",d:"Subtraction or negation.",e:`(- 10 3) ;=> 7
(- 5) ;=> -5`},"*":{s:"(* number*) \u2192 product",d:"Returns the product. With no args returns 1.",e:"(* 2 3 4) ;=> 24"},"/":{s:"(/ number+) \u2192 quotient",d:"Division. With one arg returns reciprocal.",e:`(/ 10 3) ;=> 10/3
(/ 2) ;=> 1/2`},"=":{s:"(= number+) \u2192 boolean",d:"Numeric equality.",e:"(= 1 1.0) ;=> T"},"<":{s:"(< number+) \u2192 boolean",d:"Strictly increasing.",e:"(< 1 2 3) ;=> T"},">":{s:"(> number+) \u2192 boolean",d:"Strictly decreasing.",e:"(> 3 2 1) ;=> T"},"<=":{s:"(<= number+) \u2192 boolean",d:"Non-decreasing.",e:"(<= 1 1 2) ;=> T"},">=":{s:"(>= number+) \u2192 boolean",d:"Non-increasing.",e:"(>= 3 3 1) ;=> T"},"/=":{s:"(/= number+) \u2192 boolean",d:"All pairwise unequal.",e:"(/= 1 2 3) ;=> T"},"1+":{s:"(1+ number) \u2192 number",d:"Returns number + 1.",e:"(1+ 41) ;=> 42"},"1-":{s:"(1- number) \u2192 number",d:"Returns number - 1.",e:"(1- 43) ;=> 42"},abs:{s:"(abs number) \u2192 number",d:"Absolute value.",e:"(abs -5) ;=> 5"},max:{s:"(max number+) \u2192 number",d:"Returns the maximum.",e:"(max 1 3 2) ;=> 3"},min:{s:"(min number+) \u2192 number",d:"Returns the minimum.",e:"(min 1 3 2) ;=> 1"},mod:{s:"(mod number divisor) \u2192 modulus",d:"Modulus (sign follows divisor). Related to FLOOR.",e:`(mod 10 3) ;=> 1
(mod -10 3) ;=> 2`},rem:{s:"(rem number divisor) \u2192 remainder",d:"Remainder (sign follows number). Related to TRUNCATE.",e:"(rem -10 3) ;=> -1"},floor:{s:"(floor number &optional divisor) \u2192 quotient, remainder",d:"Rounds toward negative infinity. Returns two values.",e:`(floor 7 2) ;=> 3, 1
(floor -7 2) ;=> -4, 1`},ceiling:{s:"(ceiling number &optional divisor) \u2192 quotient, remainder",d:"Rounds toward positive infinity.",e:"(ceiling 7 2) ;=> 4, -1"},round:{s:"(round number &optional divisor) \u2192 quotient, remainder",d:"Rounds to nearest even integer.",e:`(round 7 2) ;=> 4, -1
(round 2.5) ;=> 2, 0.5`},truncate:{s:"(truncate number &optional divisor) \u2192 quotient, remainder",d:"Rounds toward zero.",e:`(truncate 7 2) ;=> 3, 1
(truncate -7 2) ;=> -3, -1`},expt:{s:"(expt base power) \u2192 result",d:"Base raised to the power.",e:"(expt 2 10) ;=> 1024"},sqrt:{s:"(sqrt number) \u2192 result",d:"Square root.",e:"(sqrt 16) ;=> 4.0"},gcd:{s:"(gcd integer*) \u2192 integer",d:"Greatest common divisor.",e:"(gcd 12 18) ;=> 6"},lcm:{s:"(lcm integer*) \u2192 integer",d:"Least common multiple.",e:"(lcm 4 6) ;=> 12"},ash:{s:"(ash integer count) \u2192 integer",d:"Arithmetic shift. Positive count shifts left, negative shifts right.",e:`(ash 1 10) ;=> 1024
(ash 1024 -5) ;=> 32`},logand:{s:"(logand integer*) \u2192 integer",d:"Bitwise AND.",e:"(logand #xFF #x0F) ;=> 15"},logior:{s:"(logior integer*) \u2192 integer",d:"Bitwise inclusive OR.",e:"(logior #xF0 #x0F) ;=> 255"},logxor:{s:"(logxor integer*) \u2192 integer",d:"Bitwise exclusive OR.",e:"(logxor #xFF #x0F) ;=> 240"},"parse-integer":{s:"(parse-integer string &key start end radix junk-allowed) \u2192 integer, position",d:"Parses a string as an integer.",e:`(parse-integer "42") ;=> 42, 2
(parse-integer "ff" :radix 16) ;=> 255, 2`},format:{s:"(format destination control-string arg*) \u2192 result",d:"Formatted output. destination: T (stdout), NIL (return string), or stream. Key directives: ~A (aesthetic), ~S (standard), ~D (decimal), ~F (float), ~% (newline), ~& (fresh-line), ~{ ~} (iteration), ~[ ~] (conditional).",e:`(format t "~A is ~D~%" name age)
(format nil "~{~A~^, ~}" list)
(format t "~,2F" 3.14159) ;=> "3.14"`},print:{s:"(print object &optional stream) \u2192 object",d:"Prints object with a preceding newline and trailing space; uses escape syntax.",e:'(print "hello") ; outputs \\n"hello" '},prin1:{s:"(prin1 object &optional stream) \u2192 object",d:"Prints object in a readable (escaped) form.",e:'(prin1 "hello") ; outputs "hello" with quotes'},princ:{s:"(princ object &optional stream) \u2192 object",d:"Prints object without escape characters (human-readable).",e:'(princ "hello") ; outputs hello without quotes'},write:{s:"(write object &key stream escape radix base ...) \u2192 object",d:"The general output function. All other print functions are defined in terms of WRITE.",e:"(write 255 :base 16) ; outputs FF"},terpri:{s:"(terpri &optional stream) \u2192 NIL",d:"Outputs a newline.",e:"(terpri)"},read:{s:"(read &optional stream eof-error-p eof-value recursive-p) \u2192 object",d:"Reads one Lisp object from stream.",e:"(read) ; reads from *standard-input*"},"read-line":{s:"(read-line &optional stream eof-error-p eof-value recursive-p) \u2192 string, missing-newline-p",d:"Reads a line of text.",e:"(read-line)"},"read-from-string":{s:"(read-from-string string &optional eof-error-p eof-value &key start end preserve-whitespace) \u2192 object, position",d:"Reads a Lisp object from a string.",e:'(read-from-string "(+ 1 2)") ;=> (+ 1 2), 7'},"string-upcase":{s:"(string-upcase string &key start end) \u2192 string",d:"Returns uppercased copy.",e:'(string-upcase "hello") ;=> "HELLO"'},"string-downcase":{s:"(string-downcase string &key start end) \u2192 string",d:"Returns lowercased copy.",e:'(string-downcase "HELLO") ;=> "hello"'},"string-trim":{s:"(string-trim char-bag string) \u2192 string",d:"Removes characters in char-bag from both ends.",e:'(string-trim " " "  hello  ") ;=> "hello"'},"make-hash-table":{s:"(make-hash-table &key test size rehash-size rehash-threshold) \u2192 hash-table",d:"Creates a hash table. Test can be EQ, EQL, EQUAL, or EQUALP.",e:"(make-hash-table :test 'equal)"},gethash:{s:"(gethash key hash-table &optional default) \u2192 value, present-p",d:"Looks up key. Returns value and T, or default and NIL. SETFable.",e:`(gethash :name table)
(setf (gethash :name table) "Alice")`},remhash:{s:"(remhash key hash-table) \u2192 boolean",d:"Removes the entry for key. Returns T if found.",e:"(remhash :name table)"},maphash:{s:"(maphash function hash-table) \u2192 NIL",d:"Calls function with each key and value in the hash table.",e:'(maphash (lambda (k v) (format t "~A: ~A~%" k v)) table)'},"make-instance":{s:"(make-instance class &rest initargs) \u2192 instance",d:"Creates a new CLOS instance.",e:`(make-instance 'person :name "Alice" :age 30)`},"slot-value":{s:"(slot-value object slot-name) \u2192 value",d:"Accesses a slot. SETFable.",e:"(slot-value person 'name)"},"class-of":{s:"(class-of object) \u2192 class",d:"Returns the class of object.",e:"(class-of 42) ;=> #<BUILT-IN-CLASS FIXNUM>"},"type-of":{s:"(type-of object) \u2192 type",d:"Returns a type specifier for object.",e:`(type-of 42) ;=> (INTEGER 0 ...)
(type-of "hi") ;=> (SIMPLE-BASE-STRING 2)`},"make-array":{s:"(make-array dimensions &key element-type initial-element initial-contents adjustable fill-pointer) \u2192 array",d:"Creates an array.",e:`(make-array 5 :initial-element 0)
(make-array '(3 3) :initial-element 0)`},aref:{s:"(aref array index*) \u2192 element",d:"Accesses an array element. SETFable.",e:`(aref arr 0)
(setf (aref arr 0) 42)`},vector:{s:"(vector object*) \u2192 simple-vector",d:"Creates a simple vector.",e:"(vector 1 2 3) ;=> #(1 2 3)"},error:{s:"(error datum &rest args)",d:"Signals an error condition. datum can be a string, format control, or condition type.",e:`(error "~A not found" name)
(error 'my-error :reason "failed")`},cerror:{s:"(cerror continue-string datum &rest args)",d:"Signals a correctable error with a CONTINUE restart.",e:'(cerror "Skip it" "Bad value: ~A" x)'},warn:{s:"(warn datum &rest args)",d:"Signals a warning condition.",e:'(warn "Deprecated: use ~A instead" new-name)'},signal:{s:"(signal datum &rest args)",d:"Signals a condition without entering the debugger if unhandled.",e:"(signal 'my-condition)"},intern:{s:"(intern string &optional package) \u2192 symbol, status",d:"Finds or creates a symbol in package.",e:'(intern "FOO") ;=> FOO, :INTERNAL'},gensym:{s:"(gensym &optional prefix) \u2192 symbol",d:"Creates a unique uninterned symbol. Essential for macro hygiene.",e:`(gensym) ;=> #:G42
(gensym "MY-") ;=> #:MY-43`},"symbol-name":{s:"(symbol-name symbol) \u2192 string",d:"Returns the print name of the symbol.",e:`(symbol-name 'hello) ;=> "HELLO"`},"symbol-value":{s:"(symbol-value symbol) \u2192 value",d:"Returns the dynamic value of the symbol.",e:"(symbol-value '*package*)"},"make-string-output-stream":{s:"(make-string-output-stream &key element-type) \u2192 stream",d:"Creates a stream that accumulates characters into a string.",e:`(let ((s (make-string-output-stream)))
  (write-string "hello" s)
  (get-output-stream-string s))`},"get-output-stream-string":{s:"(get-output-stream-string stream) \u2192 string",d:"Returns the accumulated string and resets the stream.",e:'(get-output-stream-string s) ;=> "hello"'},open:{s:"(open path &key direction element-type if-exists if-does-not-exist external-format) \u2192 stream",d:"Opens a file. Direction: :input, :output, :io, :probe.",e:'(open "file.txt" :direction :input)'},close:{s:"(close stream &key abort) \u2192 t",d:"Closes a stream.",e:"(close stream)"},pathname:{s:"(pathname pathspec) \u2192 pathname",d:"Converts to a pathname object.",e:'(pathname "src/main.lisp")'},"ensure-directories-exist":{s:"(ensure-directories-exist pathspec &key verbose) \u2192 pathspec, created",d:"Creates directories as needed.",e:'(ensure-directories-exist "out/data/file.txt")'},"call-next-method":{s:"(call-next-method &rest args) \u2192 result*",d:"Calls the next method in a DEFMETHOD. Can only be used inside a method.",e:`(defmethod foo :around ((x thing))
  (print "before")
  (call-next-method)
  (print "after"))`},"find-restart":{s:"(find-restart identifier &optional condition) \u2192 restart",d:"Finds a restart by name.",e:"(find-restart 'continue)"},"invoke-restart":{s:"(invoke-restart restart &rest args) \u2192 |",d:"Invokes the named restart.",e:"(invoke-restart 'continue)"},load:{s:"(load filespec &key verbose print if-does-not-exist external-format) \u2192 boolean",d:"Loads a file (source or compiled).",e:'(load "init.lisp")'},"compile-file":{s:"(compile-file input-file &key output-file verbose print external-format) \u2192 output, warnings-p, failure-p",d:"Compiles a source file to a FASL.",e:'(compile-file "my-code.lisp")'},sleep:{s:"(sleep seconds) \u2192 NIL",d:"Suspends execution for the given number of seconds.",e:"(sleep 0.5)"},room:{s:"(room &optional verbosity) \u2192 |",d:"Prints information about memory usage.",e:"(room t)"},documentation:{s:"(documentation x doc-type) \u2192 string",d:"Returns the documentation string.",e:"(documentation 'car 'function)"}},f="commonlisp";c.languages.register({id:f,extensions:[".lisp",".lsp",".cl",".asd",".asdf",".ros"],aliases:["Common Lisp","commonlisp","CL","cl"]}),c.languages.setLanguageConfiguration(f,{comments:{lineComment:";",blockComment:["#|","|#"]},brackets:[["(",")"],["[","]"]],autoClosingPairs:[{open:"(",close:")"},{open:"[",close:"]"},{open:'"',close:'"',notIn:["string"]},{open:"|",close:"|"}],surroundingPairs:[{open:"(",close:")"},{open:"[",close:"]"},{open:'"',close:'"'},{open:"|",close:"|"}],wordPattern:/(?::?[a-zA-Z_!$%&*/<=>?^~][a-zA-Z0-9_!$%&*/<=>?^~+\-.:#]*)|(?:&[a-zA-Z-]+)|(?:1[+-])|(?:[+\-*/<>=!]+)/,indentationRules:{increaseIndentPattern:/^\s*\(.*[^)]\s*$/,decreaseIndentPattern:/^\s*\)/},onEnterRules:[{beforeText:/\([^)]*$/,action:{indentAction:c.languages.IndentAction.Indent}}]}),c.languages.setMonarchTokensProvider(f,{ignoreCase:!0,specialOps:L,defForms:R,macros:T,builtins:v,constants:w,tokenizer:{root:[[/\s+/,"white"],[/#\|/,"comment","@blockComment"],[/;.*$/,"comment"],[/"/,"string","@string"],[/#\\(?:space|newline|tab|return|backspace|page|rubout|linefeed|nul|null|alarm|escape)\b/,"string"],[/#\\x[0-9a-fA-F]+/,"string"],[/#\\./,"string"],[/\|/,"string.escape","@escapedSymbol"],[/#'/,"tag"],[/#[+-]/,"meta"],[/#\./,"meta"],[/#[cC]\(/,"number"],[/#\*[01]*/,"number"],[/#\d*[aA]\(/,"delimiter"],[/#\(/,"delimiter"],[/#[bB][01]+/,"number"],[/#[oO][0-7]+/,"number"],[/#[xX][0-9a-fA-F]+/,"number"],[/#\d+[rR][0-9a-zA-Z]+/,"number"],[/#:/,"tag"],[/:[a-zA-Z_!$%&*/<=>?^~+\-][a-zA-Z0-9_!$%&*/<=>?^~+\-.]*/,"constant"],[/:/,"constant"],[/&(?:optional|rest|key|allow-other-keys|body|whole|environment|aux)\b/,"variable"],[/1[+-](?=[\s()[\]";#|]|$)/,"type.identifier"],[/[+-]?\d+\.\d*(?:[eEsSfFdDlL][+-]?\d+)?/,"number.float"],[/[+-]?\.\d+(?:[eEsSfFdDlL][+-]?\d+)?/,"number.float"],[/[+-]?\d+[eEsSfFdDlL][+-]?\d+/,"number.float"],[/[+-]?\d+\/\d+/,"number"],[/[+-]?\d+\.?/,"number"],[/[()[\]]/,"delimiter.parenthesis"],[/,@/,"tag"],[/[',`]/,"tag"],[/[a-zA-Z_!$%&*/<=>?^~][a-zA-Z0-9_!$%&*/<=>?^~+\-.]*::?[a-zA-Z_!$%&*/<=>?^~+\-][a-zA-Z0-9_!$%&*/<=>?^~+\-.]*/,"identifier"],[/[a-zA-Z_!$%&*/<=>?^~][a-zA-Z0-9_!$%&*/<=>?^~+\-.]*/,{cases:{"@specialOps":"keyword","@defForms":"keyword","@macros":"keyword","@builtins":"type.identifier","@constants":"constant","@default":"identifier"}}],[/\*[a-zA-Z_!$%&/<=>?^~][a-zA-Z0-9_!$%&*/<=>?^~+\-.]*\*/,{cases:{"@constants":"constant","@default":"identifier"}}],[/\+[a-zA-Z_!$%&/<=>?^~][a-zA-Z0-9_!$%&*/<=>?^~+\-.]*\+/,{cases:{"@constants":"constant","@default":"identifier"}}],[/[+-][a-zA-Z_!$%&*/<=>?^~][a-zA-Z0-9_!$%&*/<=>?^~+\-.]*/,{cases:{"@builtins":"type.identifier","@constants":"constant","@default":"identifier"}}],[/\/=/,"type.identifier"],[/[<>]=?/,"type.identifier"],[/[+\-*/=/]/,"type.identifier"]],string:[[/[^\\"]+/,"string"],[/\\./,"string.escape"],[/"/,"string","@pop"]],blockComment:[[/#\|/,"comment","@push"],[/\|#/,"comment","@pop"],[/[^#|]+/,"comment"],[/./,"comment"]],escapedSymbol:[[/[^|]+/,"string.escape"],[/\|/,"string.escape","@pop"]]}});function h(i){let a=[],o=i.getLineCount();for(let t=1;t<=o;t++){let r=i.getLineContent(t),e=r.match(/\(\s*(defun|defmacro|defgeneric)\s+([a-zA-Z_!$%&*/<=>?^~+\-][a-zA-Z0-9_!$%&*/<=>?^~+\-.]*)/i);if(e){let s=r.indexOf(e[2],e.index+e[1].length)+1;a.push({name:e[2],line:t,col:s,kind:e[1].toLowerCase()==="defmacro"?"macro":"function",form:e[1]});continue}if(e=r.match(/\(\s*defmethod\s+([a-zA-Z_!$%&*/<=>?^~+\-][a-zA-Z0-9_!$%&*/<=>?^~+\-.]*)/i),e){let s=r.indexOf(e[1],e.index)+1;a.push({name:e[1],line:t,col:s,kind:"method",form:"defmethod"});continue}if(e=r.match(/\(\s*(defvar|defparameter|defconstant)\s+([a-zA-Z_!$%&*/<=>?^~+\-][a-zA-Z0-9_!$%&*/<=>?^~+\-.]*)/i),e){let s=r.indexOf(e[2],e.index+e[1].length)+1;a.push({name:e[2],line:t,col:s,kind:"variable",form:e[1]});continue}if(e=r.match(/\(\s*defclass\s+([a-zA-Z_!$%&*/<=>?^~+\-][a-zA-Z0-9_!$%&*/<=>?^~+\-.]*)/i),e){let s=r.indexOf(e[1],e.index)+1;a.push({name:e[1],line:t,col:s,kind:"class",form:"defclass"});continue}if(e=r.match(/\(\s*defstruct\s+(?:\(\s*)?([a-zA-Z_!$%&*/<=>?^~+\-][a-zA-Z0-9_!$%&*/<=>?^~+\-.]*)/i),e){let s=r.indexOf(e[1],e.index)+1;a.push({name:e[1],line:t,col:s,kind:"struct",form:"defstruct"});continue}if(e=r.match(/\(\s*defpackage\s+(?::)?([a-zA-Z_!$%&*/<=>?^~+\-][a-zA-Z0-9_!$%&*/<=>?^~+\-.]*)/i),e){let s=r.indexOf(e[1],e.index)+1;a.push({name:e[1],line:t,col:s,kind:"package",form:"defpackage"});continue}if(e=r.match(/\(\s*deftype\s+([a-zA-Z_!$%&*/<=>?^~+\-][a-zA-Z0-9_!$%&*/<=>?^~+\-.]*)/i),e){let s=r.indexOf(e[1],e.index)+1;a.push({name:e[1],line:t,col:s,kind:"type",form:"deftype"});continue}if(e=r.match(/\(\s*define-condition\s+([a-zA-Z_!$%&*/<=>?^~+\-][a-zA-Z0-9_!$%&*/<=>?^~+\-.]*)/i),e){let s=r.indexOf(e[1],e.index)+1;a.push({name:e[1],line:t,col:s,kind:"condition",form:"define-condition"})}}return a}function x(i,a){let o=i.getWordAtPosition(a);if(o)return o.word;let t=i.getLineContent(a.lineNumber),r=a.column-1,e=t[r];if(!e)return null;if(/[+\-*/<>=!?&:$%^~]/.test(e)){let s=/[a-zA-Z0-9_!$%&*/<=>?^~+\-.:]/,l=r,d=r;for(;l>0&&s.test(t[l-1]);)l--;for(;d<t.length-1&&s.test(t[d+1]);)d++;return t.substring(l,d+1)}return null}function $(i){if(!i)return null;let a=i.toLowerCase();return A[a]||null}c.languages.registerCompletionItemProvider(f,{triggerCharacters:["("],provideCompletionItems:function(i,a){let o=i.getWordUntilPosition(a),t={startLineNumber:a.lineNumber,endLineNumber:a.lineNumber,startColumn:o.startColumn,endColumn:o.endColumn},r=c.languages.CompletionItemInsertTextRule.InsertAsSnippet,e=c.languages.CompletionItemKind,s=[],l=[{l:"defun",det:"Define a function",ins:'defun ${1:name} (${2:args})\n  ${3:"Documentation."}\n  ${4:body}',doc:'(defun name (args) "doc" body)'},{l:"defmacro",det:"Define a macro",ins:'defmacro ${1:name} (${2:args})\n  ${3:"Documentation."}\n  ${4:body}',doc:'(defmacro name (args) "doc" body)'},{l:"defvar",det:"Define special variable",ins:'defvar ${1:*name*} ${2:value}\n  ${3:"Documentation."}',doc:'(defvar *name* value "doc")'},{l:"defparameter",det:"Define special parameter",ins:'defparameter ${1:*name*} ${2:value}\n  ${3:"Documentation."}',doc:"(defparameter *name* value)"},{l:"defconstant",det:"Define constant",ins:"defconstant ${1:+name+} ${2:value}",doc:"(defconstant +name+ value)"},{l:"defclass",det:"Define a CLOS class",ins:"defclass ${1:name} (${2:})\n  ((${3:slot} :initarg :${3:slot}\n          :accessor ${1:name}-${3:slot}\n          :initform ${4:nil}))",doc:"(defclass name (supers) ((slot :initarg ...)))"},{l:"defmethod",det:"Define a method",ins:"defmethod ${1:name} ((${2:obj} ${3:class}))\n  ${4:body}",doc:"(defmethod name ((obj class)) body)"},{l:"defgeneric",det:"Define a generic function",ins:'defgeneric ${1:name} (${2:args})\n  (:documentation ${3:"Documentation."})',doc:'(defgeneric name (args) (:documentation "..."))'},{l:"defstruct",det:"Define a structure",ins:"defstruct ${1:name}\n  (${2:slot1} ${3:nil})\n  (${4:slot2} ${5:nil})",doc:"(defstruct name (slot default) ...)"},{l:"defpackage",det:"Define a package",ins:"defpackage :${1:name}\n  (:use :cl)\n  (:export :${2:sym})",doc:"(defpackage :name (:use :cl) (:export ...))"},{l:"let",det:"Let binding",ins:"let ((${1:var} ${2:val}))\n  ${3:body}",doc:"(let ((var val)) body)"},{l:"let*",det:"Sequential let",ins:"let* ((${1:var} ${2:val}))\n  ${3:body}",doc:"(let* ((var val)) body)"},{l:"lambda",det:"Anonymous function",ins:"lambda (${1:args})\n  ${2:body}",doc:"(lambda (args) body)"},{l:"if",det:"Conditional",ins:"if ${1:test}\n    ${2:then}\n    ${3:else}",doc:"(if test then else)"},{l:"cond",det:"Multi-way conditional",ins:"cond\n  ((${1:test1}) ${2:expr1})\n  (t ${3:default})",doc:"(cond (test expr) ... (t default))"},{l:"case",det:"Case dispatch",ins:"case ${1:keyform}\n  ((${2:key}) ${3:form})\n  (otherwise ${4:default})",doc:"(case keyform ((key) form) (otherwise default))"},{l:"loop collect",det:"Loop with collect",ins:"loop for ${1:var} ${2:in} ${3:list}\n      collect ${4:expr}",doc:"(loop for var in list collect expr)"},{l:"loop do",det:"Loop with do",ins:"loop for ${1:i} from ${2:0} below ${3:n}\n      do ${4:(print i)}",doc:"(loop for i from 0 below n do ...)"},{l:"loop with hash",det:"Loop over hash table",ins:'loop for ${1:key} being the hash-keys of ${2:table}\n      using (hash-value ${3:val})\n      do ${4:(format t "~A: ~A~%" $1 $3)}',doc:"(loop for k being the hash-keys of ht using (hash-value v) do ...)"},{l:"dolist",det:"Iterate over list",ins:"dolist (${1:var} ${2:list})\n  ${3:body}",doc:"(dolist (var list) body)"},{l:"dotimes",det:"Count-controlled loop",ins:"dotimes (${1:i} ${2:n})\n  ${3:body}",doc:"(dotimes (i n) body)"},{l:"when",det:"When expression",ins:"when ${1:test}\n  ${2:body}",doc:"(when test body)"},{l:"unless",det:"Unless expression",ins:"unless ${1:test}\n  ${2:body}",doc:"(unless test body)"},{l:"handler-case",det:"Exception handling",ins:'handler-case\n    ${1:form}\n  (${2:error} (${3:c})\n    ${4:(format t "Error: ~A" c)})',doc:"(handler-case form (type (c) handler))"},{l:"restart-case",det:"Restart handling",ins:'restart-case\n    ${1:form}\n  (${2:retry} ()\n    :report ${3:"Retry"}\n    ${4:body})',doc:'(restart-case form (name () :report "..." body))'},{l:"with-open-file",det:"File I/O",ins:'with-open-file (${1:stream} ${2:"file.txt"}\n                :direction :${3:input})\n  ${4:body}',doc:"(with-open-file (s path :direction :input) body)"},{l:"multiple-value-bind",det:"Bind multiple values",ins:"multiple-value-bind (${1:a} ${2:b}) ${3:(floor 10 3)}\n  ${4:body}",doc:"(multiple-value-bind (a b) (floor 10 3) body)"},{l:"destructuring-bind",det:"Destructure a list",ins:"destructuring-bind (${1:a} ${2:b} &rest ${3:c}) ${4:list}\n  ${5:body}",doc:"(destructuring-bind (a b &rest c) list body)"},{l:"format string",det:"Format to string",ins:'format nil "${1:~A}" ${2:arg}',doc:'(format nil "~A" arg) \u2192 string'},{l:"format t",det:"Format to stdout",ins:'format t "${1:~A~%}" ${2:arg}',doc:'(format t "~A~%" arg)'},{l:"flet",det:"Local function",ins:"flet ((${1:name} (${2:args})\n         ${3:body}))\n  ${4:form})",doc:"(flet ((name (args) body)) form)"},{l:"labels",det:"Recursive local functions",ins:"labels ((${1:name} (${2:args})\n           ${3:body}))\n  ${4:form})",doc:"(labels ((name (args) body)) form)"},{l:"with-output-to-string",det:"Capture output to string",ins:'with-output-to-string (${1:s})\n  ${2:(format s "~A" val)}',doc:"(with-output-to-string (s) body) \u2192 string"},{l:"unwind-protect",det:"Cleanup form",ins:"unwind-protect\n    ${1:protected-form}\n  ${2:cleanup-form}",doc:"(unwind-protect protected cleanup)"},{l:"print-unreadable-object",det:"#<...> printing",ins:'print-unreadable-object (${1:obj} ${2:stream} :type t)\n  ${3:(format stream "~A" (slot-value obj \'name))}',doc:"(print-unreadable-object (obj stream :type t) body)"}];for(let n of l)s.push({label:n.l,kind:e.Snippet,insertText:n.ins,insertTextRules:r,detail:"Snippet: "+n.det,documentation:{value:"```lisp\n("+n.doc+")\n```"},range:t,sortText:"0_"+n.l});for(let n of k){let p=$(n);s.push({label:n,kind:e.Keyword,insertText:n,detail:"keyword / special form",documentation:p?{value:"```lisp\n"+p.s+"\n```\n"+p.d}:void 0,range:t,sortText:"1_"+n})}for(let n of v){if(k.includes(n))continue;let p=$(n);s.push({label:n,kind:e.Function,insertText:n,detail:"built-in function",documentation:p?{value:"```lisp\n"+p.s+"\n```\n"+p.d}:void 0,range:t,sortText:"2_"+n})}for(let n of w)s.push({label:n,kind:e.Constant,insertText:n,detail:"constant",range:t,sortText:"2_"+n});let d=["&optional","&rest","&key","&allow-other-keys","&body","&whole","&environment","&aux"];for(let n of d)s.push({label:n,kind:e.Keyword,insertText:n,detail:"lambda list keyword",range:t,sortText:"3_"+n});let b=[":initarg",":initform",":accessor",":reader",":writer",":allocation",":type",":documentation",":key",":test",":test-not",":start",":end",":from-end",":count",":initial-value",":direction",":input",":output",":io",":if-exists",":if-does-not-exist",":supersede",":append",":overwrite",":new-version",":error",":rename",":rename-and-delete",":element-type",":external-format",":adjustable",":fill-pointer",":initial-element",":initial-contents",":displaced-to",":displaced-index-offset",":use",":export",":import-from",":shadow",":shadowing-import-from",":nicknames",":report",":interactive",":before",":after",":around",":instance",":class"];for(let n of b)s.push({label:n,kind:e.Property,insertText:n,detail:"keyword argument",range:t,sortText:"4_"+n});let y=["integer","fixnum","bignum","float","single-float","double-float","short-float","long-float","rational","real","complex","number","bit","unsigned-byte","signed-byte","character","base-char","standard-char","string","simple-string","base-string","simple-base-string","symbol","keyword","null","boolean","atom","cons","list","proper-list","sequence","vector","simple-vector","array","simple-array","bit-vector","simple-bit-vector","hash-table","function","compiled-function","generic-function","method","stream","file-stream","string-stream","broadcast-stream","concatenated-stream","two-way-stream","echo-stream","synonym-stream","pathname","logical-pathname","package","readtable","random-state","condition","error","warning","serious-condition","simple-error","simple-warning","type-error","arithmetic-error","division-by-zero","cell-error","unbound-variable","undefined-function","control-error","program-error","style-warning","standard-object","structure-object","class","standard-class","built-in-class","structure-class","method-combination","t"];for(let n of y)s.push({label:n,kind:e.TypeParameter,insertText:n,detail:"type specifier",range:t,sortText:"5_"+n});let g=["for","as","with","do","doing","collect","collecting","append","appending","nconc","nconcing","count","counting","sum","summing","maximize","maximizing","minimize","minimizing","into","in","on","across","being","each","the","hash-key","hash-keys","hash-value","hash-values","of","using","from","to","below","above","downto","downfrom","upfrom","by","then","while","until","repeat","always","never","thereis","if","when","unless","else","end","finally","initially","return","named"];for(let n of g)s.push({label:n,kind:e.Keyword,insertText:n,detail:"LOOP keyword",range:t,sortText:"6_"+n});let u=[{l:"~A",d:"Aesthetic: prints object readably (like PRINC)"},{l:"~S",d:"Standard: prints object with escape chars (like PRIN1)"},{l:"~D",d:"Decimal integer"},{l:"~B",d:"Binary integer"},{l:"~O",d:"Octal integer"},{l:"~X",d:"Hexadecimal integer"},{l:"~R",d:"Radix / English cardinal / ordinal"},{l:"~F",d:"Fixed-format float: ~w,d,k,overflowchar,padcharF"},{l:"~E",d:"Exponential float"},{l:"~G",d:"General float (auto F or E)"},{l:"~$",d:"Monetary float"},{l:"~C",d:"Character"},{l:"~%",d:"Newline (terpri)"},{l:"~&",d:"Fresh line"},{l:"~~",d:"Literal tilde"},{l:"~T",d:"Tabulate"},{l:"~*",d:"Go to argument"},{l:"~?",d:"Recursive processing"},{l:"~{...~}",d:"Iteration: apply body to list elements"},{l:"~[...~]",d:"Conditional: ~[false~;true~]"},{l:"~^",d:"Escape upward (terminate ~{ early)"},{l:"~P",d:"Plural: prints s if arg /= 1"},{l:"~|",d:"Page separator"}];for(let n of u)s.push({label:n.l,kind:e.Value,insertText:n.l.replace(/^~/,"~"),detail:"FORMAT: "+n.d,range:t,sortText:"7_"+n.l});let m=h(i),C=new Set([...k,...v,...w].map(n=>n.toLowerCase()));for(let n of m){let p=n.name.toLowerCase();C.has(p)||(C.add(p),s.push({label:n.name,kind:n.kind==="function"||n.kind==="method"?e.Function:n.kind==="macro"?e.Module:n.kind==="class"||n.kind==="struct"?e.Class:n.kind==="package"?e.Module:n.kind==="type"||n.kind==="condition"?e.Interface:e.Variable,insertText:n.name,detail:"user: "+n.form+" (line "+n.line+")",range:t,sortText:"3_"+n.name}))}return{suggestions:s}}}),c.languages.registerHoverProvider(f,{provideHover:function(i,a){let o=x(i,a);if(!o)return null;let t=$(o);if(t){let l=i.getWordAtPosition(a),d=[{value:"```lisp\n"+t.s+"\n```"},{value:t.d}];return t.e&&d.push({value:"**Example:**\n```lisp\n"+t.e+"\n```"}),{range:l?new c.Range(a.lineNumber,l.startColumn,a.lineNumber,l.endColumn):void 0,contents:d}}let r={"&optional":"Marks optional parameters. Each can be (var default supplied-p).","&rest":"Binds remaining arguments as a list.","&key":"Marks keyword parameters. Each can be ((keyword var) default supplied-p).","&allow-other-keys":"Allows unrecognized keyword arguments.","&body":"Like &REST but signals that the argument is a body (affects indentation).","&whole":"Binds the entire macro form (destructuring).","&environment":"Binds the macro expansion environment.","&aux":"Introduces auxiliary local variables."},e=o.toLowerCase();if(r[e])return{contents:[{value:"**Lambda List Keyword**"},{value:r[e]}]};let s=h(i);for(let l of s)if(l.name.toLowerCase()===e)return{contents:[{value:"```lisp\n"+i.getLineContent(l.line).trim()+"\n```"},{value:"User-defined **"+l.kind+"** via `"+l.form+"` \u2014 *line "+l.line+"*"}]};return null}}),c.languages.registerDefinitionProvider(f,{provideDefinition:function(i,a){let o=x(i,a);if(!o)return null;let t=o.toLowerCase(),r=h(i),e=[];for(let s of r)s.name.toLowerCase()===t&&e.push({uri:i.uri,range:new c.Range(s.line,s.col,s.line,s.col+s.name.length)});return e.length?e:null}}),c.languages.registerDocumentSymbolProvider(f,{provideDocumentSymbols:function(i){let a=h(i),o=c.languages.SymbolKind;return a.map(function(t){return{name:t.name,detail:t.form,kind:t.kind==="function"?o.Function:t.kind==="method"?o.Method:t.kind==="macro"?o.Module:t.kind==="class"?o.Class:t.kind==="struct"?o.Struct:t.kind==="package"?o.Package:t.kind==="type"||t.kind==="condition"?o.Interface:o.Variable,range:new c.Range(t.line,1,t.line,i.getLineContent(t.line).length+1),selectionRange:new c.Range(t.line,t.col,t.line,t.col+t.name.length)}})}}),c.languages.registerReferenceProvider(f,{provideReferences:function(i,a){let o=x(i,a);if(!o)return null;let t=[],r=i.getLineCount(),e=o.replace(/[.*+?^${}()|[\]\\\/]/g,"\\$&"),s=new RegExp("(?<=[\\s(\\[,`'#]|^)"+e+'(?=[\\s)\\]";]|$)',"gi");for(let l=1;l<=r;l++){let d=i.getLineContent(l),b;for(;(b=s.exec(d))!==null;)t.push({uri:i.uri,range:new c.Range(l,b.index+1,l,b.index+1+o.length)})}return t}}),c.languages.registerSignatureHelpProvider(f,{signatureHelpTriggerCharacters:["("," "],provideSignatureHelp:function(i,a){let o=i.getValueInRange({startLineNumber:Math.max(1,a.lineNumber-10),startColumn:1,endLineNumber:a.lineNumber,endColumn:a.column}),t=0,r=-1;for(let u=o.length-1;u>=0;u--){let m=o[u];if(m===")")t++;else if(m==="("){if(t===0){r=u+1;break}t--}}if(r<0)return null;let e=o.substring(r).trim(),s=e.match(/^([a-zA-Z_!$%&*/<=>?^~+\-][a-zA-Z0-9_!$%&*/<=>?^~+\-.]*)/);if(!s)return null;let l=s[1].toLowerCase(),d=A[l];if(!d)return null;let b=e.substring(s[0].length),y=0,g=0;for(let u=0;u<b.length;u++){let m=b[u];m==="("||m==="["?g++:m===")"||m==="]"?g--:m===" "&&g===0&&y++}return{value:{signatures:[{label:d.s.split(`
`)[0],documentation:{value:d.d},parameters:[]}],activeSignature:0,activeParameter:y},dispose:function(){}}}})};export{q as default};
